<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>leetcode之二叉树</title>
    <link href="/2023/03/14/leetcode%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2023/03/14/leetcode%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h4 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></h4><p>给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。<br>示例 1：<br><img src="invert_tree.png"><br>输入：root &#x3D; [4,2,7,1,3,6,9]<br>输出：[4,7,2,9,6,3,1]</p><p>思路:<br>翻转每个节点就能翻转整个二叉树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//递归</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> root;<br>        std::<span class="hljs-built_in">swap</span>(root-&gt;left, root-&gt;right);<br>        <span class="hljs-built_in">invertTree</span>(root-&gt;left);<br>        <span class="hljs-built_in">invertTree</span>(root-&gt;right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//模拟前序遍历</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> root;<br>        std::stack&lt;TreeNode*&gt; sta;<br>        sta.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!sta.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode* t = sta.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-comment">//务必在这pop</span><br>            sta.<span class="hljs-built_in">pop</span>();<br>            std::<span class="hljs-built_in">swap</span>(t-&gt;left, t-&gt;right);<br>            <span class="hljs-comment">//左右节点 入栈顺序不要求</span><br>            <span class="hljs-keyword">if</span>(t-&gt;right) sta.<span class="hljs-built_in">push</span>(t-&gt;right);<br>            <span class="hljs-keyword">if</span>(t-&gt;left) sta.<span class="hljs-built_in">push</span>(t-&gt;left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//广度遍历</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> root;<br>        std::queue&lt;TreeNode*&gt; layer;<br>        layer.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!layer.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> n = layer.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                TreeNode* node = layer.<span class="hljs-built_in">front</span>();<br>                layer.<span class="hljs-built_in">pop</span>();<br>                std::<span class="hljs-built_in">swap</span>(node-&gt;left, node-&gt;right);<br>                <span class="hljs-keyword">if</span>(node-&gt;left) layer.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span>(node-&gt;right) layer.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></h4><p>给你一个二叉树的根节点 root ， 检查它是否轴对称。<br>示例 1：<br><img src="symmetric_tree.png"><br>输入：root &#x3D; [1,2,2,3,4,4,3]<br>输出：true</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">//层序遍历</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        std::queue&lt;TreeNode*&gt; layer;<br>        layer.<span class="hljs-built_in">push</span>(root-&gt;left);<br>        layer.<span class="hljs-built_in">push</span>(root-&gt;right);<br>        <span class="hljs-keyword">while</span>(!layer.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> n = layer.<span class="hljs-built_in">size</span>();<br>            TreeNode* node1 = layer.<span class="hljs-built_in">front</span>();<br>            layer.<span class="hljs-built_in">pop</span>();<br>            TreeNode* node2 = layer.<span class="hljs-built_in">front</span>();<br>            layer.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(!node1 &amp;&amp; !node2) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(!node1 || !node2) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span>(node1-&gt;val != node2-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            layer.<span class="hljs-built_in">push</span>(node1-&gt;left);<br>            layer.<span class="hljs-built_in">push</span>(node2-&gt;right);<br>            layer.<span class="hljs-built_in">push</span>(node1-&gt;right);<br>            layer.<span class="hljs-built_in">push</span>(node2-&gt;left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h4><p>给定一个二叉树，找出其最大深度。<br>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br>说明: 叶子节点是指没有子节点的节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//递归</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxDepth</span>(root-&gt;left), <span class="hljs-built_in">maxDepth</span>(root-&gt;right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">//层序遍历</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        queue&lt;TreeNode*&gt; l;<br>        l.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> depth = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!l.<span class="hljs-built_in">empty</span>()) &#123;<br>            depth++;<br>            <span class="hljs-type">int</span> n = l.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                TreeNode* node = l.<span class="hljs-built_in">front</span>();<br>                l.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(node-&gt;left) l.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span>(node-&gt;right) l.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> depth;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="559-N-叉树的最大深度"><a href="#559-N-叉树的最大深度" class="headerlink" title="559. N 叉树的最大深度"></a><a href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/">559. N 叉树的最大深度</a></h4><p>给定一个 N 叉树，找到其最大深度。<br>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。<br>N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。<br>示例 1：<br>输入：root &#x3D; [1,null,3,2,4,null,5,6]<br>输出：3</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        queue&lt;Node*&gt; l;<br>        l.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> depth = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!l.<span class="hljs-built_in">empty</span>()) &#123;<br>            depth++;<br>            <span class="hljs-type">int</span> n = l.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                Node* node = l.<span class="hljs-built_in">front</span>();<br>                l.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; child : node-&gt;children) &#123;<br>                    l.<span class="hljs-built_in">push</span>(child);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> depth;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111.二叉树的最小深度"></a><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111.二叉树的最小深度</a></h4><p>给定一个二叉树，找出其最小深度。<br>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。<br>说明：叶子节点是指没有子节点的节点。<br>示例 1：<br>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：2<br>示例 2：<br>输入：root &#x3D; [2,null,3,null,4,null,5,null,6]<br>输出：5<br>提示：</p><p>树中节点数的范围在 [0, 105] 内<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        queue&lt;TreeNode*&gt; l;<br>        l.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> depth = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!l.<span class="hljs-built_in">empty</span>()) &#123;<br>            depth++;<br>            <span class="hljs-type">int</span> n = l.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                TreeNode* node = l.<span class="hljs-built_in">front</span>();<br>                l.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(!node-&gt;left &amp;&amp; !node-&gt;right) <span class="hljs-keyword">return</span> depth;<br>                <span class="hljs-keyword">if</span>(node-&gt;left) l.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span>(node-&gt;right) l.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> depth;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a>222. 完全二叉树的节点个数</h4><p>给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。</p><p>完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p><p>示例 1：<br><img src="222_example_1.png"></p><p>输入：root &#x3D; [1,2,3,4,5,6]<br>输出：6<br>示例 2：</p><p>输入：root &#x3D; []<br>输出：0<br>示例 3：</p><p>输入：root &#x3D; [1]<br>输出：1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">//前序遍历</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>        stack&lt;TreeNode*&gt; s;<br>        s.<span class="hljs-built_in">push</span>(root);<br>        TreeNode* cur = root;<br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* node = s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            ++n;<br>            <span class="hljs-keyword">if</span>(node-&gt;right) s.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            <span class="hljs-keyword">if</span>(node-&gt;left) s.<span class="hljs-built_in">push</span>(node-&gt;left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">//中序遍历</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>        stack&lt;TreeNode*&gt; s;<br>        TreeNode* cur = root;<br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>() || cur) &#123;<br>            <span class="hljs-keyword">if</span> (cur) &#123;<br>                s.<span class="hljs-built_in">push</span>(cur);<br>                cur = cur-&gt;left;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                TreeNode* node = s.<span class="hljs-built_in">top</span>();<br>                s.<span class="hljs-built_in">pop</span>();<br>                ++n;<br>                cur = node-&gt;right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">//层序遍历</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>        queue&lt;TreeNode*&gt; s;<br>        s.<span class="hljs-built_in">push</span>(root);<br>        TreeNode* cur = root;<br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> node = s.<span class="hljs-built_in">front</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            ++n;<br>            <span class="hljs-keyword">if</span>(node-&gt;left) s.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            <span class="hljs-keyword">if</span>(node-&gt;right) s.<span class="hljs-built_in">push</span>(node-&gt;right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 递归</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>TreeNode* left = root-&gt;left;<br>TreeNode* right = root-&gt;right;<br><span class="hljs-type">int</span> leftDeep = <span class="hljs-number">0</span>, rightDeep = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">countNodes</span>(root-&gt;left) + <span class="hljs-built_in">countNodes</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">//区分满二叉树和非满二叉树两种情况</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">auto</span> leftNode = root-&gt;left;<br>        <span class="hljs-keyword">auto</span> rightNode = root-&gt;right;<br>        <span class="hljs-type">int</span> leftDeepth = <span class="hljs-number">0</span>, rightDeepth = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(leftNode) &#123;<br>            ++leftDeepth;<br>            leftNode = leftNode-&gt;left;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(rightNode) &#123;<br>            ++rightDeepth;<br>            rightNode = rightNode-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (leftDeepth == rightDeepth) <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span> &lt;&lt; leftDeepth) - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">countNodes</span>(root-&gt;left) + <span class="hljs-built_in">countNodes</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110.平衡二叉树"></a><a href="https://leetcode.cn/problems/balanced-binary-tree/">110.平衡二叉树</a></h4><p>给定一个二叉树，判断它是否是高度平衡的二叉树。<br>本题中，一棵高度平衡二叉树定义为：<br>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。<br>示例 1：<br><img src="110_example_1.png"></p><p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：true<br>示例 2：<br><img src="110_example_2.png"></p><p>输入：root &#x3D; [1,2,2,3,3,null,null,4,4]<br>输出：false<br>示例 3：<br>输入：root &#x3D; []<br>输出：true</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countHeight</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">countHeight</span>(root-&gt;left), <span class="hljs-built_in">countHeight</span>(root-&gt;right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-type">int</span> leftDeepth = <span class="hljs-built_in">countHeight</span>(root-&gt;left);<br>        <span class="hljs-type">int</span> rightDeepth = <span class="hljs-built_in">countHeight</span>(root-&gt;right);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(leftDeepth - rightDeepth) &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isBalanced</span>(root-&gt;left) &amp;&amp; <span class="hljs-built_in">isBalanced</span>(root-&gt;right);<br>   &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257.二叉树的所有路径"></a><a href="https://leetcode.cn/problems/binary-tree-paths/">257.二叉树的所有路径</a></h4><p>给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。<br>叶子节点 是指没有子节点的节点。<br>示例 1：<br>输入：root &#x3D; [1,2,3,null,5]<br>输出：[“1-&gt;2-&gt;5”,”1-&gt;3”]<br>示例 2：</p><p>输入：root &#x3D; [1]<br>输出：[“1”]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">//回溯</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt;&amp; path, vector&lt;string&gt;&amp; result)</span> </span>&#123;<br>        path.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br><br>        <span class="hljs-keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;<br>            string s;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; path.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; ++i) &#123;<br>                s.<span class="hljs-built_in">append</span>(to_string[path[i]]).<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;-&gt;&quot;</span>);<br>            &#125;<br>            s.<span class="hljs-built_in">append</span>(<span class="hljs-built_in">to_string</span>(path[path.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]));<br>            result.<span class="hljs-built_in">emplace_back</span>(std::<span class="hljs-built_in">move</span>(s));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root-&gt;left) &#123;<br>            <span class="hljs-built_in">traverse</span>(root-&gt;left, path, result);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root-&gt;right) &#123;<br>            <span class="hljs-built_in">traverse</span>(root-&gt;right, path, result);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125; <br>    &#125;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;string&gt; result;<br>        vector&lt;<span class="hljs-type">int</span>&gt; paths;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> result;<br>        <span class="hljs-built_in">traverse</span>(root, path, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//迭代</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        stack&lt;TreeNode*&gt; treeSt;<span class="hljs-comment">// 保存树的遍历节点</span><br>        stack&lt;string&gt; pathSt;   <span class="hljs-comment">// 保存遍历路径的节点</span><br>        vector&lt;string&gt; result;  <span class="hljs-comment">// 保存最终路径集合</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> result;<br>        treeSt.<span class="hljs-built_in">push</span>(root);<br>        pathSt.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">to_string</span>(root-&gt;val));<br>        <span class="hljs-keyword">while</span> (!treeSt.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* node = treeSt.<span class="hljs-built_in">top</span>(); treeSt.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 取出节点 中</span><br>            string path = pathSt.<span class="hljs-built_in">top</span>();pathSt.<span class="hljs-built_in">pop</span>();    <span class="hljs-comment">// 取出该节点对应的路径</span><br>            <span class="hljs-keyword">if</span> (node-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; node-&gt;right == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">// 遇到叶子节点</span><br>                result.<span class="hljs-built_in">push_back</span>(path);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (node-&gt;right) &#123; <span class="hljs-comment">// 右</span><br>                treeSt.<span class="hljs-built_in">push</span>(node-&gt;right);<br>                pathSt.<span class="hljs-built_in">push</span>(path + <span class="hljs-string">&quot;-&gt;&quot;</span> + <span class="hljs-built_in">to_string</span>(node-&gt;right-&gt;val));<br>            &#125;<br>            <span class="hljs-keyword">if</span> (node-&gt;left) &#123; <span class="hljs-comment">// 左</span><br>                treeSt.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                pathSt.<span class="hljs-built_in">push</span>(path + <span class="hljs-string">&quot;-&gt;&quot;</span> + <span class="hljs-built_in">to_string</span>(node-&gt;left-&gt;val));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112.路径总和"></a><a href="https://leetcode.cn/problems/path-sum/">112.路径总和</a></h4><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。</p><p>叶子节点 是指没有子节点的节点。<br>示例 1：<br>输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum &#x3D; 22<br>输出：true<br>解释：等于目标和的根节点到叶节点路径如上图所示。<br>示例 2：</p><p>输入：root &#x3D; [1,2,3], targetSum &#x3D; 5<br>输出：false<br>解释：树中存在两条根节点到叶子节点的路径：<br>(1 –&gt; 2): 和为 3<br>(1 –&gt; 3): 和为 4<br>不存在 sum &#x3D; 5 的根节点到叶子节点的路径。<br>示例 3：</p><p>输入：root &#x3D; [], targetSum &#x3D; 0<br>输出：false<br>解释：由于树是空的，所以不存在根节点到叶子节点的路径。</p><p>提示：</p><p>树中节点的数目在范围 [0, 5000] 内<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000<br>-1000 &lt;&#x3D; targetSum &lt;&#x3D; 1000</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">//递归</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> count)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) <span class="hljs-keyword">return</span> count == <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(root-&gt;left) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">traverse</span>(root-&gt;left, count - root-&gt;left-&gt;val)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root-&gt;right) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">traverse</span>(root-&gt;right, count - root-&gt;right-&gt;val)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> targetSum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traverse</span>(root, targetSum - root-&gt;val);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">//递归简化</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> targetSum)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span> (root-&gt;val == targetSum &amp;&amp; !root-&gt;left &amp;&amp;!root-&gt;right) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">hasPathSum</span>(root-&gt;left, targetSum - root-&gt;val) || <span class="hljs-built_in">hasPathSum</span>(root-&gt;right, targetSum - root-&gt;val);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113.路径总和 II"></a><a href="https://leetcode.cn/problems/path-sum-ii/">113.路径总和 II</a></h4><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p><p>叶子节点 是指没有子节点的节点。</p><p>示例 1：</p><p>输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22<br>输出：[[5,4,11,2],[5,8,4,5]]<br>示例 2：</p><p>输入：root &#x3D; [1,2,3], targetSum &#x3D; 5<br>输出：[]<br>示例 3：</p><p>输入：root &#x3D; [1,2], targetSum &#x3D; 0<br>输出：[]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">//递归 回溯</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; paths;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> count)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) &#123;<br>            <span class="hljs-keyword">if</span>(count == <span class="hljs-number">0</span>) &#123;<br>                result.<span class="hljs-built_in">push_back</span>(paths);<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root-&gt;left) &#123;<br>            paths.<span class="hljs-built_in">push_back</span>(root-&gt;left-&gt;val);<br>            <span class="hljs-built_in">traverse</span>(root-&gt;left, count - root-&gt;left-&gt;val);<br>            paths.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//回溯</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(root-&gt;right) &#123;<br>            paths.<span class="hljs-built_in">push_back</span>(root-&gt;right-&gt;val);<br>            <span class="hljs-built_in">traverse</span>(root-&gt;right, count - root-&gt;right-&gt;val);<br>            paths.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//回溯</span><br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pathSum</span>(TreeNode* root, <span class="hljs-type">int</span> targetSum) &#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> result;<br>        paths.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">traverse</span>(root, targetSum - root-&gt;val);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404.左叶子之和"></a><a href="https://leetcode.cn/problems/sum-of-left-leaves/">404.左叶子之和</a></h4><p>给定二叉树的根节点 root ，返回所有左叶子之和。<br>示例 1：<br>输入: root &#x3D; [3,9,20,null,null,15,7]<br>输出: 24<br>解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24<br>示例 2:</p><p>输入: root &#x3D; [1]<br>输出: 0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">//前序</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumOfLeftLeaves</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        stack&lt;TreeNode*&gt; s;<br>        s.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> node = s.<span class="hljs-built_in">top</span>();s.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-comment">//左叶子结点</span><br>            <span class="hljs-keyword">if</span> (node-&gt;left &amp;&amp; !node-&gt;left-&gt;left &amp;&amp; !node-&gt;left-&gt;right) sum += node-&gt;left-&gt;val;<br>            <span class="hljs-keyword">if</span>(node-&gt;right) s.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            <span class="hljs-keyword">if</span>(node-&gt;left) s.<span class="hljs-built_in">push</span>(node-&gt;left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">//递归</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumOfLeftLeaves</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) sum = root-&gt;left-&gt;val;<br>        <span class="hljs-keyword">return</span> sum + <span class="hljs-built_in">sumOfLeftLeaves</span>(root-&gt;left) + <span class="hljs-built_in">sumOfLeftLeaves</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513. 找树左下角的值"></a>513. 找树左下角的值</h4><p>给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。<br>假设二叉树中至少有一个节点。<br>示例 1:<br>输入: root &#x3D; [2,1,3]<br>输出: 1<br>示例 2:<br>输入: [1,2,3,4,null,5,6,null,null,7]<br>输出: 7</p><p>思路：<br>最大深度的最靠左节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">//层序遍历</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        queue&lt;TreeNode*&gt; layer;<br>        layer.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!layer.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> n = layer.<span class="hljs-built_in">size</span>();<br>            result = layer.<span class="hljs-built_in">front</span>()-&gt;val;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                <span class="hljs-keyword">auto</span> node = layer.<span class="hljs-built_in">front</span>();<br>                layer.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-comment">//必须先插入lef节点</span><br>                <span class="hljs-keyword">if</span>(node-&gt;left) layer.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span>(node-&gt;right) layer.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">//递归</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> maxDepth = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> depth)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) &#123;<br>            <span class="hljs-keyword">if</span> (depth &gt; maxDepth) &#123;<br>                maxDepth = depth;<br>                result = root-&gt;val;<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root-&gt;left) &#123;<br>            <span class="hljs-built_in">traverse</span>(root-&gt;left, depth + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root-&gt;right) &#123;<br>            <span class="hljs-built_in">traverse</span>(root-&gt;right, depth + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">traverse</span>(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode之贪心</title>
    <link href="/2023/03/07/leetcode%E4%B9%8B%E8%B4%AA%E5%BF%83/"/>
    <url>/2023/03/07/leetcode%E4%B9%8B%E8%B4%AA%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<h4 id="贪心算法百科"><a href="#贪心算法百科" class="headerlink" title="贪心算法百科"></a>贪心算法百科</h4><blockquote><p>贪心算法（英语：greedy algorithm），又称贪婪算法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。</p></blockquote><blockquote><p>贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思是局部最优解能决定全局最优解。简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。</p></blockquote><blockquote><p>贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。</p></blockquote><blockquote><p>贪心法可以解决一些最优化问题，如：求图中的最小生成树、求哈夫曼编码……对于其他问题，贪心法一般不能得到我们所要求的答案。一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最好办法。由于贪心法的高效性以及其所求得的答案比较接近最优结果，贪心法也可以用作辅助算法或者直接解决一些要求结果不特别精确的问题。在不同情况，选择最优的解，可能会导致辛普森悖论（Simpson’s Paradox），不一定出现最优的解。</p></blockquote><h4 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455.分发饼干"></a><a href="https://leetcode.cn/problems/assign-cookies/">455.分发饼干</a></h4><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。<br>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;&#x3D; g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。<br>示例 1:<br>输入: g &#x3D; [1,2,3], s &#x3D; [1,1]<br>输出: 1<br>解释:<br>你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。<br>虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。<br>所以你应该输出1。<br>示例 2:<br>输入: g &#x3D; [1,2], s &#x3D; [1,2,3]<br>输出: 2<br>解释:<br>你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。<br>你拥有的饼干数量和尺寸都足以让所有孩子满足。<br>所以你应该输出2.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; g, vector&lt;<span class="hljs-type">int</span>&gt;&amp; s)</span> </span>&#123;<br><span class="hljs-comment">//按饼干尺寸从大到小分配,优先满足胃口最大的小孩</span><br>std::<span class="hljs-built_in">sort</span>(g.<span class="hljs-built_in">begin</span>(), g.<span class="hljs-built_in">end</span>());<br>std::<span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br><span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = g.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, j = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>;) &#123;<br><span class="hljs-comment">//尺寸满足</span><br><span class="hljs-keyword">if</span> (s[j] &gt;= g[i]) &#123;<br>++result;<br>--i;<br>--j;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//不满足找胃口更小的小孩</span><br>--i;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> result;<br>    &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; g, vector&lt;<span class="hljs-type">int</span>&gt;&amp; s)</span> </span>&#123;<br><span class="hljs-comment">//按饼干尺寸从小到大分配,优先满足胃口最小的小孩</span><br>std::<span class="hljs-built_in">sort</span>(g.<span class="hljs-built_in">begin</span>(), g.<span class="hljs-built_in">end</span>());<br>std::<span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br><span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; g.<span class="hljs-built_in">size</span>() &amp;&amp; j &lt; s.<span class="hljs-built_in">size</span>(); ++i,++j) &#123;<br><span class="hljs-comment">//找到满足第i个小孩的饼干</span><br><span class="hljs-keyword">while</span> (j &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; g[i] &gt; s[j]) &#123;<br>++j<br>&#125; <br><span class="hljs-keyword">if</span> (j &lt; s.<span class="hljs-built_in">size</span>()) &#123;<br>++result;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="376-摆动序列"><a href="#376-摆动序列" class="headerlink" title="376.摆动序列"></a><a href="https://leetcode.cn/problems/wiggle-subsequence/">376.摆动序列</a></h4><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。<br>例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。<br>相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。<br>子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。<br>给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。<br>示例 1：<br>输入：nums &#x3D; [1,7,4,9,2,5]<br>输出：6<br>解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。<br>示例 2：<br>输入：nums &#x3D; [1,17,5,10,13,15,10,5,16,8]<br>输出：7<br>解释：这个序列包含几个长度为 7 摆动序列。<br>其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。<br>示例 3：<br>输入：nums &#x3D; [1,2,3,4,5,6,7,8,</p><h5 id="思路-参照Leetcode官方题解"><a href="#思路-参照Leetcode官方题解" class="headerlink" title="思路(参照Leetcode官方题解)"></a>思路(参照Leetcode官方题解)</h5><p>观察这个序列可以发现，我们不断地交错选择「峰」与「谷」，可以使得该序列尽可能长。证明非常简单：如果我们选择了一个「过渡元素」，那么在原序列中，这个「过渡元素」的两侧有一个「峰」和一个「谷」。不失一般性，我们假设在原序列中的出现顺序为「峰」「过渡元素」「谷」。如果「过渡元素」在选择的序列中小于其两侧的元素，那么「谷」一定没有在选择的序列中出现，我们可以将「过渡元素」替换成「谷」；同理，如果「过渡元素」在选择的序列中大于其两侧的元素，那么「峰」一定没有在选择的序列中出现，我们可以将「过渡元素」替换成「峰」。这样一来，我们总可以将任意满足要求的序列中的所有「过渡元素」替换成「峰」或「谷」。并且由于我们不断地交错选择「峰」与「谷」的方法就可以满足要求，因此这种选择方法就一定可以达到可选元素数量的最大值。</p><p>这样，我们只需要统计该序列中「峰」与「谷」的数量即可（注意序列两端的数也是「峰」或「谷」），但需要注意处理相邻的相同元素。</p><p>在实际代码中，我们记录当前序列的上升下降趋势。每次加入一个新元素时，用新的上升下降趋势与之前对比，如果出现了「峰」或「谷」，答案加一，并更新当前序列的上升下降趋势。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">wiggleMaxLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-type">int</span> prevdiff = nums[<span class="hljs-number">1</span>] - nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> ret = prevdiff != <span class="hljs-number">0</span> ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> diff = nums[i] - nums[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> ((diff &gt; <span class="hljs-number">0</span> &amp;&amp; prevdiff &lt;= <span class="hljs-number">0</span>) || (diff &lt; <span class="hljs-number">0</span> &amp;&amp; prevdiff &gt;= <span class="hljs-number">0</span>)) &#123;<br>                ret++;<br>                prevdiff = diff;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55.跳跃游戏"></a><a href="https://leetcode.cn/problems/jump-game/">55.跳跃游戏</a></h4><p>给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>判断你是否能够到达最后一个下标。<br>示例 1：<br>输入：nums &#x3D; [2,3,1,1,4]<br>输出：true<br>解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。<br>示例 2：<br>输入：nums &#x3D; [3,2,1,0,4]<br>输出：false<br>解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。<br>提示：<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 3 * 104<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 105</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//不纠结每次跳跃几步,关心可以覆盖到的范围,判定更大的覆盖范围,当覆盖范围能够完整覆盖整个数组就是可以到达终点的</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canJump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-type">int</span> covor = <span class="hljs-number">0</span>;<span class="hljs-comment">//covor代表初始可以覆盖的范围，也就是初始能覆盖到首个下标</span><br>        <span class="hljs-comment">//在所能覆盖的范围内移动</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= covor; ++i) &#123;<br>            <span class="hljs-comment">//在旧的范围内移动时可能会有更大的范围可移动</span><br>            covor = std::<span class="hljs-built_in">max</span>(covor, i + nums[i]);<br>            <span class="hljs-comment">//范围覆盖整个数组 返回true</span><br>            <span class="hljs-keyword">if</span> (covor &gt;= nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//这个算法选取了每次跳跃的最佳节点 该思路可以在游戏实战中击败对方，哈哈</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canJump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>();) &#123;<br>    <span class="hljs-type">int</span> v = nums[i];<br>    <span class="hljs-comment">//可以直接跳到最后</span><br>    <span class="hljs-keyword">if</span> (i + v + <span class="hljs-number">1</span> &gt;= nums.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-type">int</span> maxAdvance = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> advance = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (v &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">//不能跳到0节点上</span><br>    <span class="hljs-keyword">if</span> (nums[i + v] &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">//跳到节点值和距离总和最大的节点上</span><br>    <span class="hljs-type">int</span> tmp = nums[i + v] + v;<br>    <span class="hljs-keyword">if</span> (tmp &gt; maxAdvance) &#123;<br>    maxAdvance = tmp;<br>    advance = v;<br>    &#125;<br>    &#125;<br>    --v;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (maxAdvance == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    i += advance;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45.跳跃游戏 II"></a><a href="https://leetcode.cn/problems/jump-game-ii/">45.跳跃游戏 II</a></h4><p>给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。<br>每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:<br>0 &lt;&#x3D; j &lt;&#x3D; nums[i]<br>i + j &lt; n<br>返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。<br>示例 1:<br>输入: nums &#x3D; [2,3,1,1,4]<br>输出: 2<br>解释: 跳到最后一个位置的最小跳跃数是 2。<br>     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。<br>示例 2:<br>输入: nums &#x3D; [2,3,0,1,4]<br>输出: 2<br>提示:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 104<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 1000<br>题目保证可以到达 nums[n-1]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> curDistance = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 当前覆盖的最远距离下标</span><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;            <span class="hljs-comment">// 记录走的最大步数</span><br>        <span class="hljs-type">int</span> nextDistance = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 下一步覆盖的最远距离下标</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) &#123; <span class="hljs-comment">// 注意这里是小于nums.size() - 1，这是关键所在</span><br>            nextDistance = <span class="hljs-built_in">max</span>(nums[i] + i, nextDistance); <span class="hljs-comment">// 更新下一步覆盖的最远距离下标</span><br>            <span class="hljs-keyword">if</span> (i == curDistance) &#123;                 <span class="hljs-comment">// 遇到当前覆盖的最远距离下标</span><br>                curDistance = nextDistance;         <span class="hljs-comment">// 更新当前覆盖的最远距离下标</span><br>                ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>        <span class="hljs-type">int</span> jump = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>();) &#123;<br>    <span class="hljs-type">int</span> v = nums[i];<br>    <span class="hljs-comment">//可以直接跳到最后</span><br>    <span class="hljs-keyword">if</span> (i + v + <span class="hljs-number">1</span> &gt;= nums.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> jump + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> maxAdvance = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> advance = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (v &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">//不能跳到0节点上</span><br>    <span class="hljs-keyword">if</span> (nums[i + v] &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">//跳到节点值和距离总和最大的节点上</span><br>    <span class="hljs-type">int</span> tmp = nums[i + v] + v;<br>    <span class="hljs-keyword">if</span> (tmp &gt; maxAdvance) &#123;<br>    maxAdvance = tmp;<br>    advance = v;<br>    &#125;<br>    &#125;<br>    --v;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (maxAdvance == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    i += advance;<br>            ++jump;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="1005-K-次取反后最大化的数组和"><a href="#1005-K-次取反后最大化的数组和" class="headerlink" title="1005.K 次取反后最大化的数组和"></a><a href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/">1005.K 次取反后最大化的数组和</a></h4><p>给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：<br>选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。<br>重复这个过程恰好 k 次。可以多次选择同一个下标 i 。<br>以这种方式修改数组后，返回数组 可能的最大和 。<br>示例 1：<br>输入：nums &#x3D; [4,2,3], k &#x3D; 1<br>输出：5<br>解释：选择下标 1 ，nums 变为 [4,-2,3] 。<br>示例 2：<br>输入：nums &#x3D; [3,-1,0,2], k &#x3D; 3<br>输出：6<br>解释：选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。<br>示例 3：<br>输入：nums &#x3D; [2,-3,-1,5,-4], k &#x3D; 2<br>输出：13<br>解释：选择下标 (1, 4) ，nums 变为 [2,3,-1,5,4] 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestSumAfterKNegations</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-comment">//按绝对值从大到小排序</span><br>    std::<span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right) &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(left) &gt; <span class="hljs-built_in">abs</span>(right); &#125;);<br>    <span class="hljs-comment">//负数改整数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() &amp;&amp; k &gt; <span class="hljs-number">0</span>; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (nums[i] &lt; <span class="hljs-number">0</span> &amp;&amp; k &gt; <span class="hljs-number">0</span>) &#123;<br>    nums[i] *= <span class="hljs-number">-1</span>;<br>    --k;<br>    &#125;<br>    &#125;<br>    <span class="hljs-comment">//k % 2 == 0 任意一个整数偶数次转换还是整数</span><br>    <span class="hljs-comment">//k % 2 == 1 任意一个整数奇数次转换变成负数,所以去绝对值最小的数转换</span><br>    <span class="hljs-keyword">if</span> (k % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>    nums[nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] = -nums[nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">accumulate</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134.加油站"></a><a href="https://leetcode.cn/problems/gas-station/">134.加油站</a></h4><p>在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。<br>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。<br>给定两个整数数组 gas 和 cost ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。</p><p>示例 1:<br>输入: gas &#x3D; [1,2,3,4,5], cost &#x3D; [3,4,5,1,2]<br>输出: 3<br>解释:<br>从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 &#x3D; 0 + 4 &#x3D; 4 升汽油<br>开往 4 号加油站，此时油箱有 4 - 1 + 5 &#x3D; 8 升汽油<br>开往 0 号加油站，此时油箱有 8 - 2 + 1 &#x3D; 7 升汽油<br>开往 1 号加油站，此时油箱有 7 - 3 + 2 &#x3D; 6 升汽油<br>开往 2 号加油站，此时油箱有 6 - 4 + 3 &#x3D; 5 升汽油<br>开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。<br>因此，3 可为起始索引。<br>示例 2:<br>输入: gas &#x3D; [2,3,4], cost &#x3D; [3,4,3]<br>输出: -1<br>解释:<br>你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。<br>我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 &#x3D; 0 + 4 &#x3D; 4 升汽油<br>开往 0 号加油站，此时油箱有 4 - 3 + 2 &#x3D; 3 升汽油<br>开往 1 号加油站，此时油箱有 3 - 3 + 3 &#x3D; 3 升汽油<br>你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。<br>因此，无论怎样，你都不可能绕环路行驶一周。<br>提示:<br>gas.length &#x3D;&#x3D; n<br>cost.length &#x3D;&#x3D; n<br>1 &lt;&#x3D; n &lt;&#x3D; 105<br>0 &lt;&#x3D; gas[i], cost[i] &lt;&#x3D; 104</p><p>暴力解法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; gas, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; gas.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-type">int</span> rest = gas[i] - cost[i];<span class="hljs-comment">//从第i点出发 到下个点剩余油量</span><br>            <span class="hljs-type">int</span> index = (i + <span class="hljs-number">1</span>) % gas.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//下一个点</span><br>            <span class="hljs-comment">//有油 &amp;&amp; 没到起点</span><br>            <span class="hljs-keyword">while</span> (rest &gt; <span class="hljs-number">0</span> &amp;&amp; index != i) &#123;<br>                rest += gas[index] - cost[index];<br>                index = (index + <span class="hljs-number">1</span>) % gas.<span class="hljs-built_in">size</span>();<br>            &#125;<br>            <span class="hljs-comment">//index==i代表回到i点</span><br>            <span class="hljs-keyword">if</span> (rest &gt;= <span class="hljs-number">0</span> &amp;&amp; index == i) <span class="hljs-keyword">return</span> i;<br>        &#125; <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>暴力解法优化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; gas, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> n = gas.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">while</span> (i &lt; n) &#123;<br><span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> rest = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (index &lt; n) &#123;<br>rest += gas[(index + i) % n] - cost[(index + i) % n];<br>                <span class="hljs-keyword">if</span> (rest &lt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>++index;<br>&#125;<br><span class="hljs-keyword">if</span> (index == n) &#123;<br><span class="hljs-keyword">return</span> i;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>i = i + <span class="hljs-number">1</span> + index;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>贪心<br>直接从全局进行贪心选择，情况如下：<br>情况一：如果gas的总和小于cost总和，那么无论从哪里出发，一定是跑不了一圈的<br>情况二：rest[i] &#x3D; gas[i]-cost[i]为i站出发到下一站剩下的油，i从0开始计算累加到最后一站，如果累加没有出现负数，说明从0出发，油就没有断过，那么0就是起点。<br>情况三：如果累加的最小值是负数，汽车就要从非0节点出发，从后向前，看哪个节点能把这个负数填平，能把这个负数填平的节点就是出发节点。<br>        最小负数的指代意义：N个车站,在第i个车站的剩余汽油是最小负数,说明从i+1开始算到最后一个车站的rest是正数,只有i+1到N的剩余油量能抵消最小负数，说明就能从i+1开始出发。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; gas, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-type">int</span> remain = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> min = std::numeric_limits&lt;<span class="hljs-type">int</span>&gt;::<span class="hljs-built_in">max</span>();<br>        <span class="hljs-type">int</span> minIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; gas.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            remain += gas[i] - cost[i];<br>            <span class="hljs-keyword">if</span> (remain &lt; min) &#123;<br>                min = remain;<br>                minIndex = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//总消耗大于总汽油量 肯定失败</span><br>        <span class="hljs-keyword">if</span> (remain &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">//从头到尾 最少剩余油量&gt;=0 说明从不缺油 可从起始站出发</span><br>        <span class="hljs-keyword">if</span> (min &gt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = minIndex + <span class="hljs-number">1</span>; i &lt; gas.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            min += gas[i] - cost[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (min &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> minIndex + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135.分发糖果"></a><a href="https://leetcode.cn/problems/candy/">135.分发糖果</a></h4><p>n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。<br>你需要按照以下要求，给这些孩子分发糖果：<br>每个孩子至少分配到 1 个糖果。<br>相邻两个孩子评分更高的孩子会获得更多的糖果。<br>请你给每个孩子分发糖果，计算并返回需要准备的最少糖果数目 。<br>示例 1：<br>输入：ratings &#x3D; [1,0,2]<br>输出：5<br>解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。<br>示例 2：<br>输入：ratings &#x3D; [1,2,2]<br>输出：4<br>解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。<br>     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。</p><p>注意此问题：只需要保证相邻的两个孩子，评分更高的孩子拿到更多的糖果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; ratings)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = ratings.<span class="hljs-built_in">size</span>();<br><span class="hljs-comment">//每个人先发一个</span><br>        <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">candy</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-comment">//从前往后 确保 ratings[i] &gt; ratings[i - 1]的时候 candy[i] &gt; candy[i - 1]</span><br>        <span class="hljs-comment">//从左往右看 就是如果我的评分大于我左边的人 则我的糖果要比我左边的人多一个</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (ratings[i] &gt; ratings[i - <span class="hljs-number">1</span>]) &#123;<br>                candy[i] = candy[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//从右往左,如果我的评语大于右边的人,则我的糖果在不变少的前提下增加到比右边的人多，即max(右边糖果+1, 当前拥有的糖果）</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">if</span> (ratings[i] &gt; ratings[i + <span class="hljs-number">1</span>]) &#123;<br>                candy[i] = std::<span class="hljs-built_in">max</span>(candy[i], candy[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">accumulate</span>(candy.<span class="hljs-built_in">begin</span>(), candy.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="860-柠檬水找零"><a href="#860-柠檬水找零" class="headerlink" title="860.柠檬水找零"></a><a href="https://leetcode.cn/problems/lemonade-change/">860.柠檬水找零</a></h4><p>在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。<br>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。<br>注意，一开始你手头没有任何零钱。<br>给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。<br>示例 1：<br>输入：bills &#x3D; [5,5,5,10,20]<br>输出：true<br>解释：<br>前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。<br>第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。<br>第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。<br>由于所有客户都得到了正确的找零，所以我们输出 true。<br>示例 2：<br>输入：bills &#x3D; [5,5,10,10,20]<br>输出：false<br>解释：<br>前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。<br>对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。<br>对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。<br>由于不是每位顾客都得到了正确的找零，所以答案是 false。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">lemonadeChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; bills)</span> </span>&#123;<br>        <span class="hljs-type">int</span> fiveBills = <span class="hljs-number">0</span>, tenBills = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> bill : bills) &#123;<br>        <span class="hljs-keyword">if</span> (bill == <span class="hljs-number">5</span>) &#123;<br>        ++fiveBills;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bill == <span class="hljs-number">10</span>) &#123;<br>        <span class="hljs-comment">//找一张5元</span><br>        <span class="hljs-keyword">if</span> (fiveBills &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        --fiveBills;<br>        ++tenBills;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (tenBills &gt; <span class="hljs-number">0</span> &amp;&amp; fiveBills &gt; <span class="hljs-number">0</span>) &#123;<br>        --tenBills;<br>        --fiveBills;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fiveBills &gt;= <span class="hljs-number">3</span>) &#123;<br>        fiveBills -= <span class="hljs-number">3</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406.根据身高重建队列"></a><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/">406.根据身高重建队列</a></h4><p>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] &#x3D; [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。<br>请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] &#x3D; [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。<br>示例 1：<br>输入：people &#x3D; [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]<br>输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]<br>解释：<br>编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。<br>编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。<br>编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。<br>编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。<br>编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。<br>编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。<br>因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。<br>示例 2：<br>输入：people &#x3D; [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]<br>输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]<br>提示：<br>1 &lt;&#x3D; people.length &lt;&#x3D; 2000<br>0 &lt;&#x3D; hi &lt;&#x3D; 106<br>0 &lt;&#x3D; ki &lt; people.length<br>题目数据确保队列可以被重建</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; people) &#123;<br>        <span class="hljs-comment">//身高从高到底排序 k从小到大排序</span><br>        std::<span class="hljs-built_in">sort</span>(people.<span class="hljs-built_in">begin</span>(), people.<span class="hljs-built_in">end</span>(), [](vector&lt;<span class="hljs-type">int</span>&gt;&amp; left, vector&lt;<span class="hljs-type">int</span>&gt;&amp; right) &#123;<br>            <span class="hljs-keyword">if</span> (left[<span class="hljs-number">0</span>] == right[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> left[<span class="hljs-number">1</span>] &lt; right[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">return</span> left[<span class="hljs-number">0</span>] &gt; right[<span class="hljs-number">0</span>];<br>        &#125;);<br>        <span class="hljs-comment">//身高高的先插入指定位置，可以保证身高低的忘我前面排 不影响k的准确性</span><br>        <span class="hljs-comment">//同样身高的,先排k小的，如果先排k大的,再排k小的，k大的那个人 k的值就不对了</span><br>        std::vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; people.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            ans.<span class="hljs-built_in">insert</span>(ans.<span class="hljs-built_in">begin</span>() + people[i][<span class="hljs-number">1</span>], people[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><span class="hljs-comment">//优化版本 vector.insert有移动和重新扩容,性能差,我们用list维护</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; people) &#123;<br>    <span class="hljs-comment">//身高从高到底排序 k从小到大排序</span><br>    std::<span class="hljs-built_in">sort</span>(people.<span class="hljs-built_in">begin</span>(), people.<span class="hljs-built_in">end</span>(), [](vector&lt;<span class="hljs-type">int</span>&gt;&amp; left, vector&lt;<span class="hljs-type">int</span>&gt;&amp; right) &#123;<br>    <span class="hljs-keyword">if</span> (left[<span class="hljs-number">0</span>] == right[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> left[<span class="hljs-number">1</span>] &lt; right[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">return</span> left[<span class="hljs-number">0</span>] &gt; right[<span class="hljs-number">0</span>];<br>    &#125;);<br>    <span class="hljs-comment">//身高高的先插入指定位置，可以保证身高低的忘我前面排 不影响k的准确性</span><br>    <span class="hljs-comment">//同样身高的,先排k小的，如果先排k大的,再排k小的，k大的那个人 k的值就不对了</span><br>    list&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; people.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>    <span class="hljs-type">int</span> n = people[i][<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">auto</span> iter = ans.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>    ++iter;<br>    &#125;<br>    ans.<span class="hljs-built_in">insert</span>(iter, people[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> std::vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&#123;ans.<span class="hljs-built_in">begin</span>(),ans.<span class="hljs-built_in">end</span>()&#125;;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452.用最少数量的箭引爆气球"></a><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">452.用最少数量的箭引爆气球</a></h4><p>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] &#x3D; [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。<br>一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。</p><p>给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。</p><p>示例 1：</p><p>输入：points &#x3D; [[10,16],[2,8],[1,6],[7,12]]<br>输出：2<br>解释：气球可以用2支箭来爆破:<br>-在x &#x3D; 6处射出箭，击破气球[2,8]和[1,6]。<br>-在x &#x3D; 11处发射箭，击破气球[10,16]和[7,12]。<br>示例 2：</p><p>输入：points &#x3D; [[1,2],[3,4],[5,6],[7,8]]<br>输出：4<br>解释：每个气球需要射出一支箭，总共需要4支箭。<br>示例 3：</p><p>输入：points &#x3D; [[1,2],[2,3],[3,4],[4,5]]<br>输出：2<br>解释：气球可以用2支箭来爆破:</p><ul><li>在x &#x3D; 2处发射箭，击破气球[1,2]和[2,3]。</li><li>在x &#x3D; 4处射出箭，击破气球[3,4]和[4,5]。<br>提示:<br>1 &lt;&#x3D; points.length &lt;&#x3D; 105<br>points[i].length &#x3D;&#x3D; 2<br>-231 &lt;&#x3D; xstart &lt; xend &lt;&#x3D; 231 - 1</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution452</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;<br>    <span class="hljs-comment">//按Xend坐标从小到大排序</span><br>    <span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(), points.<span class="hljs-built_in">end</span>(), [](vector&lt;<span class="hljs-type">int</span>&gt;&amp; left, vector&lt;<span class="hljs-type">int</span>&gt;&amp; right) &#123; <span class="hljs-keyword">return</span> left[<span class="hljs-number">1</span>] &lt; right[<span class="hljs-number">1</span>]; &#125;);<br>    <span class="hljs-comment">//从第一个points的end发射</span><br>    <span class="hljs-type">int</span> right = points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; points.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>    <span class="hljs-comment">//i点的Xstart &gt; right 需要从i点的Xend发射</span><br>    <span class="hljs-keyword">if</span> (points[i][<span class="hljs-number">0</span>] &gt; right) &#123;<br>    ++cnt;<br>    right = points[i][<span class="hljs-number">1</span>];<br>    &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMinArrowShots2</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;<br>    <span class="hljs-comment">//按Xend坐标从小到大排序</span><br>    <span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(), points.<span class="hljs-built_in">end</span>(), [](vector&lt;<span class="hljs-type">int</span>&gt;&amp; left, vector&lt;<span class="hljs-type">int</span>&gt;&amp; right) &#123; <span class="hljs-keyword">return</span> left[<span class="hljs-number">1</span>] &lt; right[<span class="hljs-number">1</span>]; &#125;);<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; points.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>    <span class="hljs-comment">//i点的Xstart &gt; i-1的右边界 </span><br>    <span class="hljs-keyword">if</span> (points[i][<span class="hljs-number">0</span>] &gt; points[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) &#123;<br>    ++cnt;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//更新最小右边界</span><br>    points[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(points[i][<span class="hljs-number">1</span>], points[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br><br>    &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMinArrowShots3</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;<br>    <span class="hljs-comment">//按Xstart坐标从小到大排序</span><br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; points.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>    <span class="hljs-comment">//i点的Xstart &gt; right 需要从i点的Xend发射</span><br>    <span class="hljs-keyword">if</span> (points[i][<span class="hljs-number">0</span>] &gt; points[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) &#123;<br>    ++cnt;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>    points[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(points[i][<span class="hljs-number">1</span>], points[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>    &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435.无重叠区间"></a><a href="https://leetcode.cn/problems/non-overlapping-intervals/">435.无重叠区间</a></h4><p>给定一个区间的集合 intervals ，其中 intervals[i] &#x3D; [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。<br>示例 1:<br>输入: intervals &#x3D; [[1,2],[2,3],[3,4],[1,3]]<br>输出: 1<br>解释: 移除 [1,3] 后，剩下的区间没有重叠。<br>示例 2:<br>输入: intervals &#x3D; [ [1,2], [1,2], [1,2] ]<br>输出: 2<br>解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。<br>示例 3:<br>输入: intervals &#x3D; [ [1,2], [2,3] ]<br>输出: 0<br>解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//和气球题目类似,也是判定重叠</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;<br><span class="hljs-comment">//按右数值升序排序</span><br><span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), [](vector&lt;<span class="hljs-type">int</span>&gt;&amp; left, vector&lt;<span class="hljs-type">int</span>&gt;&amp; right)&#123; <span class="hljs-keyword">return</span> left[<span class="hljs-number">1</span>] &lt; right[<span class="hljs-number">1</span>];&#125;);<br><span class="hljs-comment">//不重叠数量 初始是第一个区间</span><br><span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> n = intervals.<span class="hljs-built_in">size</span>();<br><span class="hljs-type">int</span> right = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br><span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &gt;= right) &#123;<br><span class="hljs-comment">//不重叠</span><br>right = intervals[i][<span class="hljs-number">1</span>];<br>++cnt;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> n - cnt;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763.划分字母区间"></a><a href="https://leetcode.cn/problems/partition-labels/">763.划分字母区间</a></h4><p>给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。<br>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。<br>返回一个表示每个字符串片段的长度的列表。<br>示例 1：<br>输入：s &#x3D; “ababcbacadefegdehijhklij”<br>输出：[9,7,8]<br>解释：<br>划分结果为 “ababcbaca”、”defegde”、”hijhklij” 。<br>每个字母最多出现在一个片段中。<br>像 “ababcbacadefegde”, “hijhklij” 这样的划分是错误的，因为划分的片段数较少。<br>示例 2：<br>输入：s &#x3D; “eccbbbbdec”<br>输出：[10]<br>提示：<br>1 &lt;&#x3D; s.length &lt;&#x3D; 500<br>s 仅由小写英文字母组成</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(string s)</span> </span>&#123;<br><span class="hljs-comment">//记录每个字符最后出现的位置</span><br>        <span class="hljs-type">int</span> postions[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            postions[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>] = i;<br>        &#125;<br><br>        std::vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; s.<span class="hljs-built_in">size</span>()) &#123;<br><span class="hljs-comment">//假设本片段的右边界是left索引对应字符最后出现的位置</span><br>            <span class="hljs-type">int</span> right = postions[s[left] - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = left + <span class="hljs-number">1</span>; i &lt; right; ++i) &#123;<br><span class="hljs-comment">//片段内的字符在右边界之后还有,则右边界移动</span><br>                <span class="hljs-keyword">if</span> (postions[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>] &gt; right) &#123;<br>                    right = postions[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>];<br>                &#125;<br>            &#125;<br>            ans.<span class="hljs-built_in">push_back</span>(right - left + <span class="hljs-number">1</span>);<br>            left = right + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(string s)</span> </span>&#123;<br><span class="hljs-comment">//记录每个字符最后出现的位置</span><br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; postions;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            postions[s[i]] = <span class="hljs-built_in">max</span>(i, postions[s[i]]);<br>        &#125;<br>        std::vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            right = <span class="hljs-built_in">max</span>(right, postions[s[i]]);<br>            <span class="hljs-keyword">if</span> (i == right) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(right - left + <span class="hljs-number">1</span>);<br>                left = right + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="738-单调递增的数字"><a href="#738-单调递增的数字" class="headerlink" title="738.单调递增的数字"></a><a href="https://leetcode.cn/problems/monotone-increasing-digits/">738.单调递增的数字</a></h4><p>当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;&#x3D; y 时，我们称这个整数是单调递增的。<br>给定一个整数 n ，返回 小于或等于 n 的最大数字，且数字呈 单调递增 。<br>示例 1:<br>输入: n &#x3D; 10<br>输出: 9<br>示例 2:<br>输入: n &#x3D; 1234<br>输出: 1234<br>示例 3:<br>输入: n &#x3D; 332<br>输出: 299<br>提示:<br>0 &lt;&#x3D; n &lt;&#x3D; 10^9</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//适合面试</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution738</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">monotoneIncreasingDigits</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>string s = std::<span class="hljs-built_in">to_string</span>(n);<br><span class="hljs-type">int</span> flag = s.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; --i) &#123;<br><span class="hljs-keyword">if</span> (s[i - <span class="hljs-number">1</span>] &gt; s[i]) &#123;<br>flag = i;<br>--s[i - <span class="hljs-number">1</span>];<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = flag; j &lt; s.<span class="hljs-built_in">size</span>(); ++j) &#123;<br>s[j] = <span class="hljs-string">&#x27;9&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">stoi</span>(s);<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode之哈希表</title>
    <link href="/2023/03/02/leetcode%E4%B9%8B%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <url>/2023/03/02/leetcode%E4%B9%8B%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h4 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a><a href="https://leetcode.cn/problems/valid-anagram/">242.有效的字母异位词</a></h4><p>力扣题目链接(opens new window)</p><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p>示例 1: 输入: s &#x3D; “anagram”, t &#x3D; “nagaram” 输出: true</p><p>示例 2: 输入: s &#x3D; “rat”, t &#x3D; “car” 输出: false</p><p>说明: 你可以假设字符串只包含小写字母。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-type">int</span> record[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-comment">// 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了</span><br>            record[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; t.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            record[t[i] - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (record[i] != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// record数组所有元素都为零0，说明字符串s和t是字母异位词</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349.两个数组的交集"></a><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349.两个数组的交集</a></h4><p>给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。<br>示例 1：<br>输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]<br>输出：[2]<br>示例 2：<br>输入：nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]<br>输出：[9,4]<br>解释：[4,9] 也是可通过的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersection</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-function">unordered_set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s</span><span class="hljs-params">(nums1.begin(), nums1.end())</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; i : nums2) &#123;<br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">count</span>(i) ) &#123;<br>                res.<span class="hljs-built_in">push_back</span>(i);<br>                s.<span class="hljs-built_in">erase</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202.快乐数"></a><a href="https://leetcode.cn/problems/happy-number/">202.快乐数</a></h4><p>编写一个算法来判断一个数 n 是不是快乐数。<br>「快乐数」 定义为：<br>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。<br>然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。<br>如果这个过程 结果为 1，那么这个数就是快乐数。<br>如果 n 是 快乐数 就返回 true ；不是，则返回 false 。<br>示例 1：<br>输入：n &#x3D; 19<br>输出：true<br>解释：<br>12 + 92 &#x3D; 82<br>82 + 22 &#x3D; 68<br>62 + 82 &#x3D; 100<br>12 + 02 + 02 &#x3D; 1<br>示例 2：<br>输入：n &#x3D; 2<br>输出：false</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>sum += (n % <span class="hljs-number">10</span>) * (n % <span class="hljs-number">10</span>);<br>n /= <span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-keyword">return</span> sum;<br>&#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>std::unordered_set&lt;<span class="hljs-type">int</span>&gt; s;<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br><span class="hljs-type">int</span> sum = <span class="hljs-built_in">get</span>(n);<br><span class="hljs-keyword">if</span> (sum == <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">count</span>(n)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>s.<span class="hljs-built_in">insert</span>(n);<br>n = sum;<br>&#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a><a href="https://leetcode.cn/problems/two-sum/">1.两数之和</a></h4><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。<br>你可以按任意顺序返回答案。<br>示例 1：<br>输入：nums &#x3D; [2,7,11,15], target &#x3D; 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。<br>示例 2：<br>输入：nums &#x3D; [3,2,4], target &#x3D; 6<br>输出：[1,2]<br>示例 3：<br>输入：nums &#x3D; [3,3], target &#x3D; 6<br>输出：[0,1]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; m;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-type">int</span> n = target - nums[i];<br>            <span class="hljs-keyword">if</span>(m.<span class="hljs-built_in">count</span>(n) &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> &#123;m[n], i&#125;;<br>            &#125;<br>            m[nums[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="454-四数相加-II"><a href="#454-四数相加-II" class="headerlink" title="454.四数相加 II"></a><a href="https://leetcode.cn/problems/4sum-ii/">454.四数相加 II</a></h4><p>给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：<br>0 &lt;&#x3D; i, j, k, l &lt; n<br>nums1[i] + nums2[j] + nums3[k] + nums4[l] &#x3D;&#x3D; 0<br>示例 1：<br>输入：nums1 &#x3D; [1,2], nums2 &#x3D; [-2,-1], nums3 &#x3D; [-1,2], nums4 &#x3D; [0,2]<br>输出：2<br>解释：<br>两个元组如下：</p><ol><li>(0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] &#x3D; 1 + (-2) + (-1) + 2 &#x3D; 0</li><li>(1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] &#x3D; 2 + (-1) + (-1) + 0 &#x3D; 0<br>示例 2：<br>输入：nums1 &#x3D; [0], nums2 &#x3D; [0], nums3 &#x3D; [0], nums4 &#x3D; [0]<br>输出：1<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fourSumCount</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums3, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums4)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums1.<span class="hljs-built_in">size</span>();<br>        std::unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; twoSumIndex;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i :nums1) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; j : nums2) &#123;<br>                twoSumIndex[i+j]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i : nums3) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; j : nums4) &#123;<br>                result += twoSumIndex[<span class="hljs-number">0</span> - i - j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h4 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383.赎金信"></a><a href="https://leetcode.cn/problems/ransom-note/">383.赎金信</a></h4><p>给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。<br>如果可以，返回 true ；否则返回 false 。<br>magazine 中的每个字符只能在 ransomNote 中使用一次。<br>示例 1：<br>输入：ransomNote &#x3D; “a”, magazine &#x3D; “b”<br>输出：false<br>示例 2：<br>输入：ransomNote &#x3D; “aa”, magazine &#x3D; “ab”<br>输出：false<br>示例 3：<br>输入：ransomNote &#x3D; “aa”, magazine &#x3D; “aab”<br>输出：true</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canConstruct</span><span class="hljs-params">(string ransomNote, string magazine)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (magazine.<span class="hljs-built_in">size</span>() &lt; ransomNote.<span class="hljs-built_in">size</span>())<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> times[<span class="hljs-number">26</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; c : magazine) &#123;<br>         times[c - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; c : ransomNote) &#123;<br>         <span class="hljs-keyword">if</span> (times[c - <span class="hljs-string">&#x27;a&#x27;</span>] &lt;= <span class="hljs-number">0</span>) &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>         &#125;<br>         times[c - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a><a href="https://leetcode.cn/problems/3sum/">15.三数之和</a></h4><p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i !&#x3D; j、i !&#x3D; k 且 j !&#x3D; k ，同时还满足 nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0 。请<br>你返回所有和为 0 且不重复的三元组。<br>注意：答案中不可以包含重复的三元组。<br>示例 1：<br>输入：nums &#x3D; [-1,0,1,2,-1,-4]<br>输出：[[-1,-1,2],[-1,0,1]]<br>解释：<br>nums[0] + nums[1] + nums[2] &#x3D; (-1) + 0 + 1 &#x3D; 0 。<br>nums[1] + nums[2] + nums[4] &#x3D; 0 + 1 + (-1) &#x3D; 0 。<br>nums[0] + nums[3] + nums[4] &#x3D; (-1) + 2 + (-1) &#x3D; 0 。<br>不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。<br>注意，输出的顺序和三元组的顺序并不重要。<br>示例 2：<br>输入：nums &#x3D; [0,1,1]<br>输出：[]<br>解释：唯一可能的三元组和不为 0 。<br>示例 3：<br>输入：nums &#x3D; [0,0,0]<br>输出：[[0,0,0]]<br>解释：唯一可能的三元组和为 0 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>         std::<span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>         <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>         vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>         <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>         <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<br>         <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>         <span class="hljs-type">int</span> target = <span class="hljs-number">0</span> - nums[i];<br>         <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>, k = n - <span class="hljs-number">1</span>; j &lt; k;) &#123;<br>         <span class="hljs-type">int</span> sum = nums[j] + nums[k];<br>         <span class="hljs-keyword">if</span> (sum &gt; target) &#123;<br>         <span class="hljs-keyword">while</span> (j &lt; k &amp;&amp; nums[k] == nums[k - <span class="hljs-number">1</span>]) k--;<br>         k--;<br>         &#125;<br>         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target) &#123;<br>         <span class="hljs-keyword">while</span> (j &lt; k &amp;&amp; nums[j] == nums[j + <span class="hljs-number">1</span>]) j++;<br>         j++;<br>         &#125;<br>         <span class="hljs-keyword">else</span> &#123;<br>         result.<span class="hljs-built_in">emplace_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;&#123;nums[i], nums[j], nums[k]&#125;);<br>         <span class="hljs-keyword">while</span> (j &lt; k &amp;&amp; nums[k] == nums[k - <span class="hljs-number">1</span>]) k--;<br>         <span class="hljs-keyword">while</span> (j &lt; k &amp;&amp; nums[j] == nums[j + <span class="hljs-number">1</span>]) j++;<br>         j++;<br>         k--;<br>         &#125;<br>         &#125;<br>         &#125;<br>         <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18.四数之和"></a><a href="https://leetcode.cn/problems/4sum/">18.四数之和</a></h4><p>给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：</p><p>0 &lt;&#x3D; a, b, c, d &lt; n<br>a、b、c 和 d 互不相同<br>nums[a] + nums[b] + nums[c] + nums[d] &#x3D;&#x3D; target<br>你可以按 任意顺序 返回答案 。<br>示例 1：<br>输入：nums &#x3D; [1,0,-1,0,-2,2], target &#x3D; 0<br>输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]<br>示例 2：<br>输入：nums &#x3D; [2,2,2,2,2], target &#x3D; 8<br>输出：[[2,2,2,2]]<br>提示：<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 200<br>-10^9 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9<br>-10^9 &lt;&#x3D; target &lt;&#x3D; 10^9</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">fourSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; nums.<span class="hljs-built_in">size</span>(); k++) &#123;<br>            <span class="hljs-comment">// 剪枝处理</span><br>            <span class="hljs-keyword">if</span> (nums[k] &gt; target &amp;&amp; nums[k] &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 这里使用break，统一通过最后的return返回</span><br>            &#125;<br>            <span class="hljs-comment">// 对nums[k]去重</span><br>            <span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">0</span> &amp;&amp; nums[k] == nums[k - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k + <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>                <span class="hljs-comment">// 2级剪枝处理</span><br>                <span class="hljs-keyword">if</span> (nums[k] + nums[i] &gt; target &amp;&amp; nums[k] + nums[i] &gt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// 对nums[i]去重</span><br>                <span class="hljs-keyword">if</span> (i &gt; k + <span class="hljs-number">1</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-type">int</span> left = i + <span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span> (right &gt; left) &#123;<br>                    <span class="hljs-comment">// nums[k] + nums[i] + nums[left] + nums[right] &gt; target 会溢出</span><br>                    <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>) nums[k] + nums[i] + nums[left] + nums[right] &gt; target) &#123;<br>                        right--;<br>                    <span class="hljs-comment">// nums[k] + nums[i] + nums[left] + nums[right] &lt; target 会溢出</span><br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>) nums[k] + nums[i] + nums[left] + nums[right]  &lt; target) &#123;<br>                        left++;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        result.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;&#123;nums[k], nums[i], nums[left], nums[right]&#125;);<br>                        <span class="hljs-comment">// 对nums[left]和nums[right]去重</span><br>                        <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) right--;<br>                        <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) left++;<br><br>                        <span class="hljs-comment">// 找到答案时，双指针同时收缩</span><br>                        right--;<br>                        left++;<br>                    &#125;<br>                &#125;<br><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode之栈和队列</title>
    <link href="/2023/03/01/leetcode%E4%B9%8B%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <url>/2023/03/01/leetcode%E4%B9%8B%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h4 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h4><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：<br>实现 MyQueue 类：<br>void push(int x) 将元素 x 推到队列的末尾<br>int pop() 从队列的开头移除并返回元素<br>int peek() 返回队列开头的元素<br>boolean empty() 如果队列为空，返回 true ；否则，返回 false<br>说明：<br>你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek&#x2F;pop from top, size, 和 is empty 操作是合法的。<br>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。<br>示例 1：<br>输入：<br>[“MyQueue”, “push”, “push”, “peek”, “pop”, “empty”]<br>[[], [1], [2], [], [], []]<br>输出：<br>[null, null, null, 1, 1, false]<br>解释：<br>MyQueue myQueue &#x3D; new MyQueue();<br>myQueue.push(1); &#x2F;&#x2F; queue is: [1]<br>myQueue.push(2); &#x2F;&#x2F; queue is: [1, 2] (leftmost is front of the queue)<br>myQueue.peek(); &#x2F;&#x2F; return 1<br>myQueue.pop(); &#x2F;&#x2F; return 1, queue is [2]<br>myQueue.empty(); &#x2F;&#x2F; return false</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br><span class="hljs-keyword">private</span>:<br>stack&lt;<span class="hljs-type">int</span>&gt; _inStack;<br>stack&lt;<span class="hljs-type">int</span>&gt; _outStack;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">MyQueue</span>() &#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>_inStack.<span class="hljs-built_in">push</span>(x);<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span> (_outStack.<span class="hljs-built_in">empty</span>()) &#123;<br><span class="hljs-keyword">while</span> (!_inStack.<span class="hljs-built_in">empty</span>()) &#123;<br>_outStack.<span class="hljs-built_in">push</span>(_inStack.<span class="hljs-built_in">top</span>());<br>_inStack.<span class="hljs-built_in">pop</span>();<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> t = _outStack.<span class="hljs-built_in">top</span>();<br>_outStack.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> t = <span class="hljs-built_in">pop</span>();<br>_outStack.<span class="hljs-built_in">push</span>(t);<br><span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> _inStack.<span class="hljs-built_in">empty</span>() &amp;&amp; _outStack.<span class="hljs-built_in">empty</span>();<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225.用队列实现栈"></a><a href="https://leetcode.cn/problems/implement-stack-using-queues/">225.用队列实现栈</a></h4><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。<br>实现 MyStack 类：<br>void push(int x) 将元素 x 压入栈顶。<br>int pop() 移除并返回栈顶元素。<br>int top() 返回栈顶元素。<br>boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。<br>注意：<br>你只能使用队列的基本操作 —— 也就是 push to back、peek&#x2F;pop from front、size 和 is empty 这些操作。<br>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br><span class="hljs-keyword">private</span>:<br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">MyStack</span>() &#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>q.<span class="hljs-built_in">push</span>(x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> n = q.<span class="hljs-built_in">size</span>();<br><span class="hljs-comment">//把队列前n-1个元素逐个移除又加到末尾</span><br><span class="hljs-keyword">while</span> (n-- &gt; <span class="hljs-number">1</span>) &#123;<br><span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br>q.<span class="hljs-built_in">push</span>(t);<br>&#125;<br><span class="hljs-comment">//当前的队列头部元素就是移动之前的最后一个元素</span><br><span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> q.<span class="hljs-built_in">back</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> q.<span class="hljs-built_in">empty</span>();<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a><a href="https://leetcode.cn/problems/valid-parentheses/">20.有效的括号</a></h4><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。<br>有效字符串需满足：<br>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。<br>示例 1:<br>输入: “()”<br>输出: true<br>示例 2:<br>输入: “()[]{}”<br>输出: true<br>示例 3:<br>输入: “(]”<br>输出: false<br>示例 4:<br>输入: “([)]”<br>输出: false<br>示例 5:<br>输入: “{[]}”<br>输出: true</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br><span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">char</span>&gt; map;<br>map[<span class="hljs-string">&#x27;)&#x27;</span>] = <span class="hljs-string">&#x27;(&#x27;</span>;<br>map[<span class="hljs-string">&#x27;]&#x27;</span>] = <span class="hljs-string">&#x27;[&#x27;</span>;<br>map[<span class="hljs-string">&#x27;&#125;&#x27;</span>] = <span class="hljs-string">&#x27;&#123;&#x27;</span>;<br>std::stack&lt;<span class="hljs-type">char</span>&gt; sta;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br><span class="hljs-type">char</span> c = s[i];<br><span class="hljs-keyword">if</span> (map.<span class="hljs-built_in">count</span>(c)) &#123;<br><span class="hljs-keyword">if</span> (sta.<span class="hljs-built_in">empty</span>() || sta.<span class="hljs-built_in">top</span>() != map[c])<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>sta.<span class="hljs-built_in">pop</span>();<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>sta.<span class="hljs-built_in">push</span>(c);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> sta.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150.逆波兰表达式求值"></a><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150.逆波兰表达式求值</a></h4><p>给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。<br>请你计算该表达式。返回一个表示表达式值的整数。<br>注意：<br>有效的算符为 ‘+’、’-‘、’<em>‘ 和 ‘&#x2F;‘ 。<br>每个操作数（运算对象）都可以是一个整数或者另一个表达式。<br>两个整数之间的除法总是 向零截断 。<br>表达式中不含除零运算。<br>输入是一个根据逆波兰表示法表示的算术表达式。<br>答案及所有中间计算结果可以用 32 位 整数表示。<br>示例 1：<br>输入：tokens &#x3D; [“2”,”1”,”+”,”3”,”</em>“]<br>输出：9<br>解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) &#x3D; 9<br>示例 2：<br>输入：tokens &#x3D; [“4”,”13”,”5”,”&#x2F;“,”+”]<br>输出：6<br>解释：该算式转化为常见的中缀算术表达式为：(4 + (13 &#x2F; 5)) &#x3D; 6<br>示例 3：<br>输入：tokens &#x3D; [“10”,”6”,”9”,”3”,”+”,”-11”,”<em>“,”&#x2F;“,”</em>“,”17”,”+”,”5”,”+”]<br>输出：22<br>解释：该算式转化为常见的中缀算术表达式为：<br>  ((10 * (6 &#x2F; ((9 + 3) * -11))) + 17) + 5<br>&#x3D; ((10 * (6 &#x2F; (12 * -11))) + 17) + 5<br>&#x3D; ((10 * (6 &#x2F; -132)) + 17) + 5<br>&#x3D; ((10 * 0) + 17) + 5<br>&#x3D; (0 + 17) + 5<br>&#x3D; 17 + 5<br>&#x3D; 22<br>提示：<br>1 &lt;&#x3D; tokens.length &lt;&#x3D; 104<br>tokens[i] 是一个算符（”+”、”-“、”*” 或 “&#x2F;“），或是在范围 [-200, 200] 内的一个整数<br>逆波兰表达式：<br>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。<br>平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。<br>该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。<br>逆波兰表达式主要有以下两个优点：<br>去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。<br>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">evalRPN</span><span class="hljs-params">(vector&lt;string&gt; tokens)</span> </span>&#123;<br>stack&lt;<span class="hljs-type">int</span>&gt; nums;<br>unordered_map&lt;string, std::function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt;&gt; funcs;<br>funcs[<span class="hljs-string">&quot;+&quot;</span>] = [](<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right) &#123;<br><span class="hljs-keyword">return</span> left + right;<br>&#125;;<br>funcs[<span class="hljs-string">&quot;-&quot;</span>] = [](<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right) &#123;<br><span class="hljs-keyword">return</span> left - right;<br>&#125;;<br>funcs[<span class="hljs-string">&quot;*&quot;</span>] = [](<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right) &#123;<br><span class="hljs-keyword">return</span> left * right;<br>&#125;;<br>funcs[<span class="hljs-string">&quot;/&quot;</span>] = [](<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right) &#123;<br><span class="hljs-keyword">return</span> left / right;<br>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; str : tokens) &#123;<br><span class="hljs-keyword">if</span> (funcs.<span class="hljs-built_in">count</span>(str) &amp;&amp; nums.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) &#123;<br><span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">top</span>();<br>nums.<span class="hljs-built_in">pop</span>();<br><span class="hljs-type">int</span> left = nums.<span class="hljs-built_in">top</span>();<br>nums.<span class="hljs-built_in">pop</span>();<br>nums.<span class="hljs-built_in">push</span>(funcs[str](left, right));<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>nums.<span class="hljs-built_in">push</span>(std::<span class="hljs-built_in">atoi</span>(str.<span class="hljs-built_in">data</span>()));<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">top</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">evalRPN2</span><span class="hljs-params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;<br>stack&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; st;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; str : tokens) &#123;<br><span class="hljs-keyword">if</span> (str == <span class="hljs-string">&quot;+&quot;</span> || str == <span class="hljs-string">&quot;-&quot;</span> || str == <span class="hljs-string">&quot;*&quot;</span> || str == <span class="hljs-string">&quot;/&quot;</span>) &#123;<br><span class="hljs-comment">//从栈中取出两个数</span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> num1 = st.<span class="hljs-built_in">top</span>();<br>st.<span class="hljs-built_in">pop</span>();<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> num2 = st.<span class="hljs-built_in">top</span>();<br>st.<span class="hljs-built_in">pop</span>();<br><span class="hljs-comment">//计算结果压入栈</span><br><span class="hljs-keyword">if</span> (str == <span class="hljs-string">&quot;+&quot;</span>) st.<span class="hljs-built_in">push</span>(num2 + num1);<br><span class="hljs-keyword">if</span> (str == <span class="hljs-string">&quot;-&quot;</span>) st.<span class="hljs-built_in">push</span>(num2 - num1);<br><span class="hljs-keyword">if</span> (str == <span class="hljs-string">&quot;*&quot;</span>) st.<span class="hljs-built_in">push</span>(num2 * num1);<br><span class="hljs-keyword">if</span> (str == <span class="hljs-string">&quot;/&quot;</span>) st.<span class="hljs-built_in">push</span>(num2 / num1);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//非计算符号直接入栈</span><br>st.<span class="hljs-built_in">push</span>(std::<span class="hljs-built_in">stoi</span>(str));<br>&#125;<br>&#125;<br><span class="hljs-comment">//栈中只有一个数就是最后的运算结果</span><br><span class="hljs-type">int</span> result = st.<span class="hljs-built_in">top</span>();<br><span class="hljs-keyword">return</span> result;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h4><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。<br>返回 滑动窗口中的最大值 。<br>示例 1：<br>输入：nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3<br>输出：[3,3,5,5,6,7]<br>解释：<br>滑动窗口的位置                最大值</p><hr><p>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7<br>示例 2：</p><p>输入：nums &#x3D; [1], k &#x3D; 1<br>输出：[1]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//优先级队列实现</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; queue;<span class="hljs-comment">//默认最大元素作为堆顶</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            queue.<span class="hljs-built_in">emplace</span>(nums[i], i);<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result&#123;queue.<span class="hljs-built_in">top</span>().first&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            queue.<span class="hljs-built_in">emplace</span>(nums[i], i);<br>            <span class="hljs-keyword">while</span> (queue.<span class="hljs-built_in">top</span>().second &lt;= i - k) &#123;<br>                queue.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            result.<span class="hljs-built_in">push_back</span>(queue.<span class="hljs-built_in">top</span>().first);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//单调队列实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123; <span class="hljs-comment">//单调队列（从大到小）</span><br><span class="hljs-keyword">public</span>:<br>deque&lt;<span class="hljs-type">int</span>&gt; que; <span class="hljs-comment">// 使用deque来实现单调队列</span><br><span class="hljs-comment">// 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。</span><br><span class="hljs-comment">// 同时pop之前判断队列当前是否为空。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!que.<span class="hljs-built_in">empty</span>() &amp;&amp; value == que.<span class="hljs-built_in">front</span>()) &#123;<br>que.<span class="hljs-built_in">pop_front</span>();<br>&#125;<br>&#125;<br><span class="hljs-comment">// 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。</span><br><span class="hljs-comment">// 这样就保持了队列里的数值是单调从大到小的了。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br><span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>() &amp;&amp; value &gt; que.<span class="hljs-built_in">back</span>()) &#123;<br>que.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br>que.<span class="hljs-built_in">push_back</span>(value);<br><br>&#125;<br><span class="hljs-comment">// 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">front</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> que.<span class="hljs-built_in">front</span>();<br>&#125;<br>&#125;;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>MyQueue que;<br>vector&lt;<span class="hljs-type">int</span>&gt; result;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123; <span class="hljs-comment">// 先将前k的元素放进队列</span><br>que.<span class="hljs-built_in">push</span>(nums[i]);<br>&#125;<br>result.<span class="hljs-built_in">push_back</span>(que.<span class="hljs-built_in">front</span>()); <span class="hljs-comment">// result 记录前k的元素的最大值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>que.<span class="hljs-built_in">pop</span>(nums[i - k]); <span class="hljs-comment">// 滑动窗口移除最前面元素</span><br>que.<span class="hljs-built_in">push</span>(nums[i]); <span class="hljs-comment">// 滑动窗口前加入最后面的元素</span><br>result.<span class="hljs-built_in">push_back</span>(que.<span class="hljs-built_in">front</span>()); <span class="hljs-comment">// 记录对应的最大值</span><br>&#125;<br><span class="hljs-keyword">return</span> result;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347.前 K 个高频元素"></a><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347.前 K 个高频元素</a></h4><p>给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。<br>示例 1:<br>输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2<br>输出: [1,2]<br>示例 2:<br>输入: nums &#x3D; [1], k &#x3D; 1<br>输出: [1]<br>提示：<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>k 的取值范围是 [1, 数组中不相同的元素的个数]<br>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 时间复杂度：O(nlogk)</span><br><span class="hljs-comment">// 空间复杂度：O(n)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 小顶堆</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">mycomparison</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; lhs, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; rhs)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> lhs.second &gt; rhs.second;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// 要统计元素出现频率</span><br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map; <span class="hljs-comment">// map&lt;nums[i],对应出现的次数&gt;</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            map[nums[i]]++;<br>        &#125;<br><br>        <span class="hljs-comment">// 对频率排序</span><br>        <span class="hljs-comment">// 定义一个小顶堆，大小为k</span><br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, mycomparison&gt; pri_que;<br><br>        <span class="hljs-comment">// 用固定大小为k的小顶堆，扫面所有频率的数值</span><br>        <span class="hljs-keyword">for</span> (unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::iterator it = map.<span class="hljs-built_in">begin</span>(); it != map.<span class="hljs-built_in">end</span>(); it++) &#123;<br>            pri_que.<span class="hljs-built_in">push</span>(*it);<br>            <span class="hljs-keyword">if</span> (pri_que.<span class="hljs-built_in">size</span>() &gt; k) &#123; <span class="hljs-comment">// 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k</span><br>                pri_que.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(k)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            result[i] = pri_que.<span class="hljs-built_in">top</span>().first;<br>            pri_que.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a href="https://leetcode.cn/problems/min-stack/">155. 最小栈</a></h4><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。<br>实现 MinStack 类:<br>MinStack() 初始化堆栈对象。<br>void push(int val) 将元素val推入堆栈。<br>void pop() 删除堆栈顶部的元素。<br>int top() 获取堆栈顶部的元素。<br>int getMin() 获取堆栈中的最小元素。<br>示例 1:<br>输入：<br>[“MinStack”,”push”,”push”,”push”,”getMin”,”pop”,”top”,”getMin”]<br>[[],[-2],[0],[-3],[],[],[],[]]<br>输出：<br>[null,null,null,null,-3,null,0,-2]<br>解释：<br>MinStack minStack &#x3D; new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.getMin();   –&gt; 返回 -2.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">MinStack</span>() &#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>values.<span class="hljs-built_in">push_back</span>(val);<br><span class="hljs-keyword">if</span> (!min_values.<span class="hljs-built_in">empty</span>()) &#123;<br>min_values.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">min</span>(val, <span class="hljs-built_in">getMin</span>()));<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>min_values.<span class="hljs-built_in">push_back</span>(val);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>values.<span class="hljs-built_in">pop_back</span>();<br>min_values.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> values[values.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> min_values[min_values.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-keyword">private</span>:<br>std::vector&lt;<span class="hljs-type">int</span>&gt; values;<br>std::vector&lt;<span class="hljs-type">int</span>&gt; min_values;<br>&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2023/02/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/02/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h4 id="cpu执行指令的过程"><a href="#cpu执行指令的过程" class="headerlink" title="cpu执行指令的过程"></a>cpu执行指令的过程</h4><blockquote><p>每条指令本身包含操作码和操作数,比如 int a &#x3D; b + c,+就是操作码, b和c就是操作数,cpu逻辑计算单元ALU计算之前必须读取b和c的值<br>计算机系统中数据可以存储在寄存器、cpu cache 、主存中,cpu cache作为主存的一个高速缓存<br>寄存器存储不需要读取主存,直接从为数不多的通用寄存器中读写数值,速度是最快的,现在编程语言中的局部变量基本上编译器会尽量让其保存在通用寄存器上<br>主存存储的数据包含程序指令、静态数据、动态分配堆数据,这里以cpu执行一条指令的过程解释下cpu如何获取到数据:<br>    cpu通过程序计数器【也叫指令地址寄存器】获取到虚拟地址,mmu根据虚拟地址计算页表页号,判断页号是否能在当前页表下查询到,如果查询到直接获取物理地址,交还给cpu,cpu从物理地址上获取数据,如果页表中未能查询到触发缺页异常,操作系统负责分配物理内存并从磁盘上加载数据并更新页表,cpu重新通过cpu查询页表获取物理地址.<br>  为了加快虚拟地址向物理地址的转换,计算机实现了tlb缓存,映射虚拟地址-&gt;物理地址<br>    由于每个进程都有相同的虚拟地址空间,每个进程也有自己的页表.所以进程切换页表也得切换,tlb也就失效了, cache失效导致命中率降低，那么新进程的虚拟地址转换物理地址速度减慢，表现出来的就是进程执行速度减慢。线程切换由于不会变更虚拟地址空间,不需要切换页表，所以没有这个问题。</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode之链表</title>
    <link href="/2023/02/27/leetcode%E4%B9%8B%E9%93%BE%E8%A1%A8/"/>
    <url>/2023/02/27/leetcode%E4%B9%8B%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h4 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h4><p>链表和数组一样,也是一种线性表数据结构,和数组不一样的是,链表的所有数据在内存中并不是连续的,而是通过每个数据节点的指针串联起来的.因为这个原因链表不具备随机存储能力,但是插入和删除结点的性能高效,复杂度是O(1),查询第几个节点复杂度是O(n)</p><p>链表类型有单向链表、双向链表、单向循环链表、双向循环链表<br>单向链表<br><img src="%E5%8D%95%E9%93%BE%E8%A1%A8.png"><br>双链表</p><blockquote><p>每个节点有两个指针域,一个指向下一个节点,一个指向上一个节点</p></blockquote><p><img src="%E5%8F%8C%E9%93%BE%E8%A1%A8.png"></p><h4 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a><a href="https://leetcode.cn/problems/remove-linked-list-elements/">203.移除链表元素</a></h4><p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val &#x3D;&#x3D; val 的节点，并返回 新的头节点 。</p><p>示例 1：<br>输入：head &#x3D; [1,2,6,3,4,5,6], val &#x3D; 6<br>输出：[1,2,3,4,5]<br>示例 2：<br>输入：head &#x3D; [], val &#x3D; 1<br>输出：[]<br>示例 3：<br>输入：head &#x3D; [7,7,7,7], val &#x3D; 7<br>输出：[]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//设置一个虚拟头结点</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        ListNode* dumyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dumyHead-&gt;next = head;<br>        ListNode* cur = dumyHead;<br>        <span class="hljs-keyword">while</span>(cur-&gt;next) &#123;<br>            <span class="hljs-keyword">if</span> (cur-&gt;next-&gt;val == val) &#123;<br>                ListNode* t = cur-&gt;next;<br>                cur-&gt;next = cur-&gt;next-&gt;next;<br>                <span class="hljs-keyword">delete</span> t;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur = cur-&gt;next;<br>            &#125;<br>        &#125;<br>        head = dumyHead-&gt;next;<br>        <span class="hljs-keyword">delete</span> dumyHead;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//在原链表上删除</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-comment">// 删除头结点</span><br>        <span class="hljs-keyword">while</span> (head &amp;&amp; head-&gt;val == val) &#123; <span class="hljs-comment">// 注意这里不是if</span><br>            ListNode* tmp = head;<br>            head = head-&gt;next;<br>            <span class="hljs-keyword">delete</span> tmp;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-comment">// 删除非头结点</span><br>        ListNode* cur = head;<br>        <span class="hljs-keyword">while</span> (cur-&gt;next!= <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur-&gt;next-&gt;val == val) &#123;<br>                ListNode* tmp = cur-&gt;next;<br>                cur-&gt;next = cur-&gt;next-&gt;next;<br>                <span class="hljs-keyword">delete</span> tmp;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur = cur-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">206.反转链表</a></h4><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。<br>示例 1：<br>输入：head &#x3D; [1,2,3,4,5]<br>输出：[5,4,3,2,1]<br>示例 2：<br>输入：head &#x3D; [1,2]<br>输出：[2,1]<br>示例 3：<br>输入：head &#x3D; []<br>输出：[]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//非递归 从前往后翻转</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br><span class="hljs-comment">//翻转后head</span><br>        ListNode* pre = <span class="hljs-literal">nullptr</span>;<br>        ListNode* cur = head;<br>        <span class="hljs-keyword">while</span>(cur) &#123;<br><span class="hljs-comment">//保存next 因为接着要修改cur-&gt;next</span><br>            ListNode* next = cur-&gt;next;<br>            cur-&gt;next = pre;<br><span class="hljs-comment">//每次处理的节点都会成为新的头结点</span><br>            pre = cur;<br><span class="hljs-comment">//处理原链表下一个节点</span><br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>   <span class="hljs-function">ListNode* <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode* pre, ListNode* cur)</span> </span>&#123;<br>      <span class="hljs-keyword">if</span>(cur == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> pre;<br>      ListNode* next = cur-&gt;next;<br>      cur-&gt;next = pre;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverse</span>(cur, next);<br>    &#125;<br><span class="hljs-comment">//递归1 从前往后翻转</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList2</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverse</span>(<span class="hljs-literal">nullptr</span>, head);<br>    &#125;<br><span class="hljs-comment">//递归2 从后往前翻转</span><br><span class="hljs-comment">//举例 1&gt;2&gt;3&gt;4</span><br><span class="hljs-comment">//递归终止返回的过程:</span><br><span class="hljs-comment">// head = 4, return 4</span><br><span class="hljs-comment">// head = 3, last = 4, 4-&gt;3-&gt;nullptr return last=4</span><br><span class="hljs-comment">// head = 2, last = 4, 3-&gt;2-&gt;nullptr return last=4</span><br><span class="hljs-comment">// head = 1, last = 4, 2-&gt;1-&gt;nullptr return last=4</span><br><span class="hljs-comment">// 递归到底找到最后一个节点last就是最终的头结点,最后一个节点前的节点原地翻转</span><br><span class="hljs-function">ListNode* <span class="hljs-title">reverseList3</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(!head || !head-&gt;next) <span class="hljs-keyword">return</span> head;<br>ListNode* last = <span class="hljs-built_in">reverseList3</span>(head-&gt;next);<br>head-&gt;next-&gt;next = head;<br>head-&gt;next = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24.两两交换链表中的节点"></a><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24.两两交换链表中的节点</a></h4><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。<br>示例 1：<br>输入：head &#x3D; [1,2,3,4]<br>输出：[2,1,4,3]<br>示例 2：<br>输入：head &#x3D; []<br>输出：[]<br>示例 3：<br>输入：head &#x3D; [1]<br>输出：[1]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//1&gt;2&gt;3&gt;4</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* dumyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dumyHead-&gt;next = head;<br>        ListNode* cur = dumyHead;<br>        <span class="hljs-keyword">while</span>(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next) &#123;<br>            ListNode* next1 = cur-&gt;next;<br>            ListNode* next2 = next1-&gt;next;<br>            ListNode* next3 = next2-&gt;next;<br>            cur-&gt;next = next2;<br>            cur-&gt;next-&gt;next = next1;<br>            cur-&gt;next-&gt;next-&gt;next = next3;<br>            cur = cur-&gt;next-&gt;next;<br>        &#125;<br>        head = dumyHead-&gt;next;<br>        <span class="hljs-keyword">delete</span> dumyHead;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><span class="hljs-comment">//递归</span><br><span class="hljs-function">ListNode* <span class="hljs-title">swapPairs2</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(!head || !head-&gt;next) <span class="hljs-keyword">return</span> head;<br>ListNode* newHead = head-&gt;next;<br>head-&gt;next = <span class="hljs-built_in">swapPairs2</span>(newHead-&gt;next);<br>newHead-&gt;next = head;<br><span class="hljs-keyword">return</span> newHead;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19.删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19.删除链表的倒数第 N 个结点</a></h4><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。<br>示例 1：<br>输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2<br>输出：[1,2,3,5]<br>示例 2：<br>输入：head &#x3D; [1], n &#x3D; 1<br>输出：[]<br>示例 3：<br>输入：head &#x3D; [1,2], n &#x3D; 1<br>输出：[1]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        ListNode* dumyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>, head);<br>        ListNode* slow = dumyHead, *fast = dumyHead;<br>        <span class="hljs-comment">//fast先走n步</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n &amp;&amp; fast-&gt;next; ++i)<br>        &#123;<br>            fast = fast-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">//fast走到最后 slow开始走,最终slow就是倒数第index个节点的前一个节点</span><br>        <span class="hljs-keyword">while</span> (fast-&gt;next)<br>        &#123;<br>            fast = fast-&gt;next;<br>            slow = slow-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">//删除slow的next节点</span><br>        slow-&gt;next = slow-&gt;next-&gt;next;<br>        <span class="hljs-keyword">return</span> dumyHead-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160.相交链表"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160.相交链表</a></h4><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。<br>图示两个链表在节点 c1 开始相交：<br>题目数据 保证 整个链式结构中不存在环。<br>注意，函数返回结果后，链表必须 保持其原始结构 。<br>示例 1：<br>输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3<br>输出：Intersected at ‘8’<br>解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。<br>从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。<br>在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。<br>示例 2：<br>输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1<br>输出：Intersected at ‘2’<br>解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。<br>从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。<br>在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。<br>示例 3：<br>输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2<br>输出：null<br>解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。<br>由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>这两个链表不相交，因此返回 null 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//双指针</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">intersectNode_1</span><span class="hljs-params">(ListNode* headA, ListNode* headB)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!headA || !headB) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        ListNode* a = headA, * b = headB;<br>        <span class="hljs-keyword">while</span> (a != b) &#123;<br>            a = a ? a-&gt;next : headB;<br>            b = b ? b-&gt;next : headA;<br>            <span class="hljs-comment">//不能使用以下方式 两个链表不相交的话 就会死循环了，链表不相交会导致 nullptr == nullptr跳出循环返回nullptr【理解成不相交的链表让其在nullptr节点相交】 </span><br>            <span class="hljs-comment">//a = a-&gt;next ? a-&gt;next : headB;</span><br>            <span class="hljs-comment">//b = b-&gt;next ? b-&gt;next : headA;</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142.环形链表 II"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142.环形链表 II</a></h4><p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。<br>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。<br>不允许修改 链表。<br>示例 1：<br>输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。<br>示例 2：<br>输入：head &#x3D; [1,2], pos &#x3D; 0<br>输出：返回索引为 0 的链表节点<br>解释：链表中有一个环，其尾部连接到第一个节点。<br>示例 3：<br>输入：head &#x3D; [1], pos &#x3D; -1<br>输出：返回 null<br>解释：链表中没有环。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode* head)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        ListNode* slow = head;<br>        ListNode* fast = head;<br>        <span class="hljs-keyword">while</span> (fast &amp;&amp; fast-&gt;next)<br>        &#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>            <span class="hljs-keyword">if</span> (slow == fast)<br>            &#123;<br>                fast = head;<br>                <span class="hljs-keyword">while</span> (fast != slow)<br>                &#123;<br>                    fast = fast-&gt;next;<br>                    slow = slow-&gt;next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> fast;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>双指针</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode之字符串</title>
    <link href="/2023/02/23/leetcode%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2023/02/23/leetcode%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h4 id="字符串理论基础"><a href="#字符串理论基础" class="headerlink" title="字符串理论基础"></a>字符串理论基础</h4><blockquote><p>存储字符类型的变长数组</p></blockquote><h4 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串</a></h4><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。<br>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。<br>示例 1：<br>输入：s &#x3D; [“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]<br>示例 2：<br>输入：s &#x3D; [“H”,”a”,”n”,”n”,”a”,”h”]<br>输出：[“h”,”a”,”n”,”n”,”a”,”H”]</p><h5 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h5><p>我们定义两个指针（也可以说是索引下标），一个从字符串前面，一个从字符串后面，两个指针同时向中间移动，并交换元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//双指针 一个指向头 一个指向尾 ,每次交换后头尾指针往中间走</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; s)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; left &lt; right; ++left, --right) &#123;<br>std::<span class="hljs-built_in">swap</span>(s[left], s[right]);<br>&#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="541-反转字符串-II"><a href="#541-反转字符串-II" class="headerlink" title="541. 反转字符串 II"></a><a href="https://leetcode.cn/problems/reverse-string-ii/">541. 反转字符串 II</a></h4><p>给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。<br>如果剩余字符少于 k 个，则将剩余字符全部反转。<br>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。<br>示例 1：<br>输入：s &#x3D; “abcdefg”, k &#x3D; 2<br>输出：”bacdfeg”<br>示例 2：<br>输入：s &#x3D; “abcd”, k &#x3D; 2<br>输出：”bacd”</p><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>把整个字符串按照2k的长度分组,每组翻转前一半字符串<br>最后一组可能不够k个字符, 则剩余的全部字符全部翻转</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseStr</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> index = <span class="hljs-number">0</span>; index &lt; n; index += (<span class="hljs-number">2</span> * k)) &#123;<br>            <span class="hljs-keyword">if</span> (index + k &lt; n) &#123;<br>                std::<span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + index, s.<span class="hljs-built_in">begin</span>() + index + k);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                std::<span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + index, s.<span class="hljs-built_in">end</span>());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h4><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。<br>示例 1：<br>输入：s &#x3D; “We are happy.”<br>输出：”We%20are%20happy.”</p><h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>扩容数组到空格替换成”%20”后的大小<br>从后往前遍历,把空格替换成”%20”,从后往前的原因是当替换索引index的空格时, 不会覆盖空格之前的字符串,时间复杂度为o(n)<br>如果从前往后遍历,当替换索引index的空格时,为了保持替换是不会覆盖原本的字符串,需要把index之后的数据全都往后移动3个位置,时间复杂度为o(n^2)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">replaceSpace</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> oldSize = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> newSize = oldSize;<br><span class="hljs-comment">//扩容s的大小</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; c : s) &#123;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                newSize += <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        s.<span class="hljs-built_in">resize</span>(newSize);<br><span class="hljs-comment">//从后往前替换</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = newSize - <span class="hljs-number">1</span>, j = oldSize - <span class="hljs-number">1</span>; j &lt; i; j--, i--) &#123;<br>            <span class="hljs-keyword">if</span> (s[j] != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                s[i] = s[j];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                s[i] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                s[i - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>                s[i - <span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;%&#x27;</span>;<br>                i -= <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151. 反转字符串中的单词"></a><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a></h4><p>给你一个字符串 s ，请你反转字符串中 单词 的顺序。<br>单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的单词分隔开。<br>返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。<br>注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。<br>示例 1：<br>输入：s &#x3D; “the sky is blue”<br>输出：”blue is sky the”<br>示例 2：<br>输入：s &#x3D; “  hello world  “<br>输出：”world hello”<br>解释：反转后的字符串中不能存在前导空格和尾随空格。<br>示例 3：<br>输入：s &#x3D; “a good   example”<br>输出：”example good a”<br>解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。</p><h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>移除字符串中所有前导空格、尾随空格、单词之间多余的空格,这里参考 <a href="/2023/02/22/leetcode%E4%B9%8B%E6%95%B0%E7%BB%84/" title="leetcode之数组">移除元素</a><br>整体反转<br>逐个单词反转<br>举例:<br>“  hello world  “ -&gt; “hello world” -&gt; “dlrow olleh” -&gt; “world hello”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//去除所有空格,参照leetcode之数组:移除元素</span><br>    <span class="hljs-comment">//并在相邻单词之间添加空格, 快慢指针。</span><br>    <span class="hljs-function">string <span class="hljs-title">removeSpace</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (slow &gt; <span class="hljs-number">0</span>) &#123;<br>                    s[slow++] = <span class="hljs-string">&#x27; &#x27;</span>;<br>                &#125;<br>                <span class="hljs-keyword">while</span> (i &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[i] != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                    s[slow++] = s[i++];<br>                &#125;<br>            &#125;<br>        &#125;<br>        s.<span class="hljs-built_in">resize</span>(slow);<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>    <span class="hljs-comment">//反转字符串</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(string&amp; s, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = left, j = right; i &lt; j; ++i, --j) &#123;<br>            std::<span class="hljs-built_in">swap</span>(s[i], s[j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        string str = <span class="hljs-built_in">removeSpace</span>(std::<span class="hljs-built_in">move</span>(s));<br>        <span class="hljs-built_in">reverse</span>(str, <span class="hljs-number">0</span>, str.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> lastSpace = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                <span class="hljs-built_in">reverse</span>(str, lastSpace, i - <span class="hljs-number">1</span>);<br>                lastSpace = i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(str, lastSpace, str.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> str;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="剑指-Offer-58-II-左旋转字符串"><a href="#剑指-Offer-58-II-左旋转字符串" class="headerlink" title="剑指 Offer 58 - II. 左旋转字符串"></a><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串</a></h4><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。<br>示例 1：<br>输入: s &#x3D; “abcdefg”, k &#x3D; 2<br>输出: “cdefgab”<br>示例 2：<br>输入: s &#x3D; “lrloseumgh”, k &#x3D; 6<br>输出: “umghlrlose”<br>限制：<br>1 &lt;&#x3D; k &lt; s.length &lt;&#x3D; 10000</p><h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><p>举例: s &#x3D; “abcdefg” k &#x3D; 2<br>前2个字符和后面的字符分别反转,变成: bagfedc<br>整体再反转: cdefgab</p><p>时间复杂度O(n) 空间复杂度O(1)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseLeftWords</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        std::<span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">begin</span>() + n);<br>        std::<span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + n, s.<span class="hljs-built_in">end</span>());<br>        std::<span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="28-找出字符串中第一个匹配项的下标"><a href="#28-找出字符串中第一个匹配项的下标" class="headerlink" title="28. 找出字符串中第一个匹配项的下标"></a><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">28. 找出字符串中第一个匹配项的下标</a></h4><p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。<br>示例 1：<br>输入：haystack &#x3D; “sadbutsad”, needle &#x3D; “sad”<br>输出：0<br>解释：”sad” 在下标 0 和 6 处匹配。<br>第一个匹配项的下标是 0 ，所以返回 0 。<br>示例 2：<br>输入：haystack &#x3D; “leetcode”, needle &#x3D; “leeto”<br>输出：-1<br>解释：”leeto” 没有在 “leetcode” 中出现，所以返回 -1 。<br>提示：<br>1 &lt;&#x3D; haystack.length, needle.length &lt;&#x3D; 104<br>haystack 和 needle 仅由小写英文字符组成</p><h5 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h5><p>经典KMP算法题,KMP算法比较负责,这里的讲解引用leetcode的<a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">一篇文章</a></p><ol><li><p>我们首先了解一个概念:字符串最长公共前后缀,以字符串”aabaa”为例:</p><blockquote><p>字符串的前缀表有: a aa aab aaba 【前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串】<br>字符串的后缀表有: abaa baa aa a 【后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串】<br>前、后缀表中公共字符串有: a aa ,最长的aa,长度为2</p></blockquote></li><li><p>常规的暴力匹配是依次从文本串的每个位置往后匹对比N个字符，判断是否和模式串全部相同,如果第以文本串的一个字符开始不能全部匹配，就以文本串的第二个字符开始重新和模式串匹配,以此往复。这种方法的缺点就是每次匹配失败都要以模式串的起始位置重新和文本串逐个对照,时间复杂度是O(m * n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(string haystack, string needle)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = haystack.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = needle.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">//只需要匹配m-n+1次就行</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m - n + <span class="hljs-number">1</span>; ++i) &#123;<br>            <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (needle[j] != haystack[i + j]) &#123;<br>                    flag = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (flag) &#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>KMP的思想是文本串haystack的遍历索引i不会回退,当文本串haystack第i个位置和模式串needle第j个位置不相同的时候,j回退到 &#x3D;&gt; needle[0, i-1]字符串的公共前后缀长度。我们思考为什么这样是合理的呢？因为haystack在i这个位置不匹配,说明模式串needle在位置j之前的子串已经全部匹配了,而j之前的子串如果拥有公共前后缀,则只需要回到公共前后缀的后一个字符重新和haystack的第i个字符进行匹配就行了。</p></li></ol><h5 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//计算模式串各个位置i的对应子串P[0, 1, ... i - 1]的最大公共前后缀长度</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">buildNext</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; pattern)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> m = pattern.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(pattern.size(), <span class="hljs-number">0</span>)</span></span>;<br>        next[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; <span class="hljs-comment">//主串指针</span><br><span class="hljs-type">int</span> t = next[<span class="hljs-number">0</span>];<span class="hljs-comment">//模式串指针</span><br>        <span class="hljs-keyword">while</span> (j &lt; m - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (t &lt; <span class="hljs-number">0</span> || pattern[j] == pattern[t]) &#123; <span class="hljs-comment">// 匹配</span><br>         t++;<br>         j++;<br>         next[j] = t;<br>         &#125;<br>         <span class="hljs-keyword">else</span> <span class="hljs-comment">// 失配</span><br>         t = next[t];<br>         &#125;<br>        <span class="hljs-keyword">return</span> next;        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(string haystack, string needle)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = haystack.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = needle.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">if</span> (m &lt; n) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">//未实现</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; next = <span class="hljs-built_in">buildNext</span>(needle);<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(;i &lt; m &amp;&amp; j &lt; n;) &#123;<br>            <span class="hljs-keyword">if</span> (haystack[i] == needle[j]) &#123;<br>                ++i;<br>                ++j;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                j = next[j];<br>                <span class="hljs-comment">//needle首字符和haystack[i]都不匹配,则j会=-1,此时i往后移动一次,j重头开始</span><br>                <span class="hljs-keyword">if</span>(j == <span class="hljs-number">-1</span>) &#123;<br>                    ++i;<br>                    j = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (j == n) <span class="hljs-keyword">return</span> i - j;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>双指针</tag>
      
      <tag>leetcode</tag>
      
      <tag>字符串</tag>
      
      <tag>KMP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode之数组</title>
    <link href="/2023/02/22/leetcode%E4%B9%8B%E6%95%B0%E7%BB%84/"/>
    <url>/2023/02/22/leetcode%E4%B9%8B%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h4 id="数组基础理论"><a href="#数组基础理论" class="headerlink" title="数组基础理论"></a>数组基础理论</h4><p><a href="https://zh.wikipedia.org/zh-my/%E6%95%B0%E7%BB%84">维基百科</a></p><blockquote><p>数组是存储相同类型的元素的集合，分配一块连续的内存来存储。利用元素的索引（index）可以根据地址偏移计算出该元素对应的存储地址。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[<span class="hljs-number">3</span>] = &#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span> &#125;;<br><span class="hljs-comment">//b和c 其实是一样的</span><br><span class="hljs-type">int</span> a = arr[<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> b = *((<span class="hljs-type">int</span>*)(arr + <span class="hljs-number">2</span>));<br><br></code></pre></td></tr></table></figure><h4 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></h4><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。<br>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。<br>示例 1: 给定 nums &#x3D; [3,2,2,3], val &#x3D; 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。<br>示例 2: 给定 nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//双指针</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>    <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>;<br>      <span class="hljs-type">int</span> len = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-comment">//fast遍历整个数组,不等于val的N个数存到数组的前N个位置,N由slow=0开始自增</span><br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> fast=<span class="hljs-number">0</span>; fast &lt; len; fast++)<br>      &#123;<br>        <span class="hljs-keyword">if</span>(nums[fast] != val) &#123;<br>            nums[slow++] = nums[fast];<br>          &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> slow;<br>  &#125;<br>    <span class="hljs-comment">//双指针优化 题目要求可以改变数组元素的顺序</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElemet2</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> val)</span> </span>&#123;<br><span class="hljs-comment">//左指针left索引的元素不等于val,说明不用删除,则后移</span><br><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> len = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-comment">//左指针left索引的元素等于val 则替换成右指针right-1索引的数值, 右指针right-1这个数被替换到slow了,右指针right-1这个数没用了,右指针right前移</span><br>  <span class="hljs-type">int</span> right = len;<br>  <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>  <span class="hljs-keyword">if</span> (nums[left] == val) &#123;<br>  nums[left] = nums[right - <span class="hljs-number">1</span>];<br>  --right;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>  ++left;<br>&#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> left;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977. 有序数组的平方"></a><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></h4><p>给你一个按非递减顺序排序的整数数组nums返回每个数字的平方组成的新数组要求也按非递减顺序排序。<br>示例 1：<br>输入：nums &#x3D; [-4,-1,0,3,10]<br>输出：[0,1,9,16,100]<br>解释：平方后，数组变为 [16,1,0,9,100]<br>排序后，数组变为 [0,1,9,16,100]<br>示例 2：<br>输入：nums &#x3D; [-7,-3,2,3,11]<br>输出：[4,9,9,49,121]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortedSquares</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-comment">//由于任意数的平方必定是正数,nums是有序的,所以平方后最大值要么是nums[0]*nums[0]要么是nums[n-1] * nums[n - 1]</span><br>    <span class="hljs-comment">//此时可以使用双指针 i = 0 j = nums.size() - 1</span><br><span class="hljs-comment">//使用索引k指向结果数组的最后一个元素</span><br><span class="hljs-comment">//如果 nums[i] * nums[i] &gt;= nums[j] * nums[j]  则result[k] = nums[i] * nums[i] k--</span><br><span class="hljs-comment">//如果 nums[i] * nums[i] &lt; nums[j] * nums[j]  则result[k] = nums[j] * nums[j]  k--</span><br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> k = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = n - <span class="hljs-number">1</span>; i &lt;= j;) &#123;<br>            <span class="hljs-keyword">if</span> ((nums[i] * nums[i]) &gt;= (nums[j] * nums[j])) &#123;<br>                result[k--] = nums[i] * nums[i];<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                result[k--] = nums[j] * nums[j];<br>                j--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></h4><p>给定一个含有 n 个正整数的数组和一个正整数 target 。<br>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。<br>示例 1：<br>输入：target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]<br>输出：2<br>解释：子数组 [4,3] 是该条件下的长度最小的子数组。<br>示例 2：<br>输入：target &#x3D; 4, nums &#x3D; [1,4,4]<br>输出：1<br>示例 3：<br>输入：target &#x3D; 11, nums &#x3D; [1,1,1,1,1,1,1,1]<br>输出：0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//暴力求解</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-type">int</span> len = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-type">int</span> min = len + <span class="hljs-number">1</span>;<span class="hljs-comment">//代表最小子数组长度,如果存在正确答案肯定小于n+1</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j &lt; len; ++j)<br>&#123;<br>sum += nums[j];<br><span class="hljs-keyword">if</span>(sum &gt;= target)<br>&#123;<br>min = std::<span class="hljs-built_in">min</span>(min, j - i + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> min == len + <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : min;<br>&#125;<br><span class="hljs-comment">//滑动窗口</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-type">int</span> min = n + <span class="hljs-number">1</span>;<span class="hljs-comment">//代表最小子数组长度,如果存在正确答案肯定小于n+1</span><br><span class="hljs-comment">//由于必须是连续的子数组总和&gt;=target,所以使用双指针</span><br><span class="hljs-comment">//左指针初始=0</span><br><span class="hljs-comment">//右指针right初始=0,累加到sum, right后移自增, 当sum&gt;=target 计算右指针和左指针的距离distance=right - left , min=std::min(min, distance) </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> left=<span class="hljs-number">0</span>, right=<span class="hljs-number">0</span>; right &lt; n;)<br>&#123;<br>sum += nums[right];<br>++right;<br><span class="hljs-comment">//因为加上这个数可能很大 所以要不断地减去当前left索引对应的数,并且left往后移动,直到sum &lt; target</span><br><span class="hljs-keyword">while</span>(sum &gt;= target)<br>&#123;<br>min = std::<span class="hljs-built_in">min</span>(min,  right - left);<br>sum -= nums[left++];<br>&#125;<br><span class="hljs-comment">//不会有比1更短的数组了</span><br><span class="hljs-keyword">if</span>(min == <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> min == n + <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : min;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59. 螺旋矩阵 II"></a><a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></h4><p>给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。<br>示例 1：<br>输入：n &#x3D; 3<br>输出：[[1,2,3],[8,9,4],[7,6,5]]</p><p><img src="1.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//顺时针循环的方向,按照行列的切换有4个方向 行不变,列+1 | 行+1,列不变 | 行不变,列-1 | 行-1,列不变</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> DIRS[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">generateMatrix</span>(<span class="hljs-type">int</span> n) &#123;<br><span class="hljs-type">int</span> total = n * n;<br><span class="hljs-type">int</span> row = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> col = <span class="hljs-number">0</span>;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">result</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br><span class="hljs-type">int</span> dirIndex = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; total; ++i)<br>&#123;<br>result[row][col] = i + <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> nextRow = row + DIRS[dirIndex][<span class="hljs-number">0</span>];<br><span class="hljs-type">int</span> nextCol = col + DIRS[dirIndex][<span class="hljs-number">1</span>];<br><span class="hljs-comment">//边界和已访问处理</span><br><span class="hljs-keyword">if</span>(nextRow &lt; <span class="hljs-number">0</span> || nextRow &gt;= n || nextCol &lt; <span class="hljs-number">0</span> || nextCol &gt;= n || result[nextRow][nextCol] != <span class="hljs-number">0</span>) &#123;<br>dirIndex = (dirIndex + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;<br>&#125;<br>row = row + DIRS[dirIndex][<span class="hljs-number">0</span>];<br>col = col + DIRS[dirIndex][<span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></h4><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。<br>示例 1:<br>输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 9<br>输出: 4<br>解释: 9 出现在 nums 中并且下标为 4<br>示例 2:<br>输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 2<br>输出: -1<br>解释: 2 不存在 nums 中因此返回 -1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//[]闭闭区间控制</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br><span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> finish = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (start &lt;= finish) &#123;<br><span class="hljs-comment">//不能用(start + finish) / 2,start+finish可能溢出</span><br><span class="hljs-type">int</span> mid = start + (finish - start) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br><span class="hljs-keyword">return</span> mid;<br>&#125;<br><span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>finish = mid - <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>start = mid + <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><span class="hljs-comment">//[)闭开区间控制</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search2</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br><span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> finish = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">while</span> (start &lt; finish) &#123;<br><span class="hljs-comment">//不能用(start + finish) / 2,start+finish可能溢出</span><br><span class="hljs-type">int</span> mid = start + (finish - start) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br><span class="hljs-keyword">return</span> mid;<br>&#125;<br><span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>finish = mid;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>start = mid + <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br><br>#### [<span class="hljs-number">15.</span> 三数之和](https:<span class="hljs-comment">//leetcode.cn/problems/3sum/)</span><br>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == <span class="hljs-number">0</span> 。请<br>你返回所有和为 <span class="hljs-number">0</span> 且不重复的三元组。<br>注意：答案中不可以包含重复的三元组。<br>示例 <span class="hljs-number">1</span>：<br>输入：nums = [<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-4</span>]<br>输出：[[<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]]<br>解释：<br>nums[<span class="hljs-number">0</span>] + nums[<span class="hljs-number">1</span>] + nums[<span class="hljs-number">2</span>] = (<span class="hljs-number">-1</span>) + <span class="hljs-number">0</span> + <span class="hljs-number">1</span> = <span class="hljs-number">0</span> 。<br>nums[<span class="hljs-number">1</span>] + nums[<span class="hljs-number">2</span>] + nums[<span class="hljs-number">4</span>] = <span class="hljs-number">0</span> + <span class="hljs-number">1</span> + (<span class="hljs-number">-1</span>) = <span class="hljs-number">0</span> 。<br>nums[<span class="hljs-number">0</span>] + nums[<span class="hljs-number">3</span>] + nums[<span class="hljs-number">4</span>] = (<span class="hljs-number">-1</span>) + <span class="hljs-number">2</span> + (<span class="hljs-number">-1</span>) = <span class="hljs-number">0</span> 。<br>不同的三元组是 [<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>] 和 [<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>] 。<br>注意，输出的顺序和三元组的顺序并不重要。<br>示例 <span class="hljs-number">2</span>：<br>输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>输出：[]<br>解释：唯一可能的三元组和不为 <span class="hljs-number">0</span> 。<br>示例 <span class="hljs-number">3</span>：<br>输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>输出：[[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]]<br>解释：唯一可能的三元组和为 <span class="hljs-number">0</span> 。<br><br>思路:<br>我们可以对nums进行排序,由于需要满足i!=j!=k,为了可以控制i从头一直遍历到末尾,每次遍历内相当于寻找 nums[j] + nums[k] = <span class="hljs-number">0</span> - nums[i],这里可以使用双指针,左指针指向i+<span class="hljs-number">1</span>,右指针指向n<span class="hljs-number">-1</span>,和之前常规的双指针用法类似,通过比较左右指针的sum和<span class="hljs-number">0</span> - nums[i]的大小来进行指针移动,直到找到j和k<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>双指针</tag>
      
      <tag>leetcode</tag>
      
      <tag>数组</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>现代处理器架构</title>
    <link href="/2023/02/17/%E7%8E%B0%E4%BB%A3%E5%A4%84%E7%90%86%E5%99%A8%E6%9E%B6%E6%9E%84/"/>
    <url>/2023/02/17/%E7%8E%B0%E4%BB%A3%E5%A4%84%E7%90%86%E5%99%A8%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="现代处理器架构"><a href="#现代处理器架构" class="headerlink" title="现代处理器架构"></a>现代处理器架构</h2><blockquote><p>主要说说这几个方面:<br>流水线<br>多核和超线程<br>SIMD指令集<br>缓存和缓存机制</p></blockquote><h3 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h3><blockquote><p>传统的认识就是cpu的主频越高,性能越高。其实这里面有一个前提：同样的流水线架构<br>实现指令级并行</p></blockquote><h4 id="多发射-超标量处理器"><a href="#多发射-超标量处理器" class="headerlink" title="多发射-超标量处理器"></a>多发射-超标量处理器</h4><h4 id="数据依赖和延迟"><a href="#数据依赖和延迟" class="headerlink" title="数据依赖和延迟"></a>数据依赖和延迟</h4><h4 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h4><blockquote><p>减少延迟 最大化流水线和多发射的效率</p></blockquote><ul><li>条件转移指令</li></ul><h4 id="乱序执行"><a href="#乱序执行" class="headerlink" title="乱序执行"></a>乱序执行</h4><blockquote><p>编译器静态调整<br>CPU动态调整<br>让没有数据依赖的指令提前执行 提升cpu效率</p></blockquote><h4 id="多核和超线程"><a href="#多核和超线程" class="headerlink" title="多核和超线程"></a>多核和超线程</h4><h4 id="SIMD指令集-单指令多数据-single-instruction-multiple-data"><a href="#SIMD指令集-单指令多数据-single-instruction-multiple-data" class="headerlink" title="SIMD指令集 (单指令多数据 single instruction multiple data)"></a>SIMD指令集 (单指令多数据 single instruction multiple data)</h4><h4 id="CPU-CACHE"><a href="#CPU-CACHE" class="headerlink" title="CPU CACHE"></a>CPU CACHE</h4><blockquote><p>现代cpu太快了，访问内存变成了一个拖油瓶相当耗时的事情，所以增加了CPU 缓存<br>cpu缓存容量有限会进行LRU动态更新，对于程序员来说应该尽量保证代码的空间和时间局部性<br>时间局部性指的是同块内存重复使用<br>空间局部性指的是代码执行更多的访问相邻的内存</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2023/02/17</title>
    <link href="/2023/02/17/2023-02-17/"/>
    <url>/2023/02/17/2023-02-17/</url>
    
    <content type="html"><![CDATA[<h3 id="GNU与Linux"><a href="#GNU与Linux" class="headerlink" title="GNU与Linux"></a>GNU与Linux</h3><blockquote><p>一个叫Richard Matthew Stallman的大胡子美国大叔对UNIX系统封闭源码很不满意，于1984年发起了GNU计划(GNU is Not Unix，首字母递归缩写)，计划开发一个完全兼容UNIX的自由软件系统，为此专门成立了自由软件基金会(Free Software Foundation，FSF)。FSF是打算自己开发一个开源的类UNIX系统,但是进度缓慢。</p><p>后面天才小子Linus Torvalds开发出了Linux,Linus觉得GNU开源精神不错,自己也不想折腾配套的应用软件(gcc、编辑器)等,双方就进行了整合组成了完整的操作系统发行版。FSF表示没什么意见，只是坚持要求全称应该叫“GNU&#x2F;Linux”，光叫Linux 就把GNU的成果完全忽略掉了。</p><p>GNU&#x2F;Linux的诞生和发展，是一件足以影响计算机行业发展史的大事。不过好像大家都习惯简称Linux,RMS大叔至今谈到GNU没有开发出自己的操作系统就泪流满面。</p></blockquote><h3 id="linux-redhat-debian-centos-redhat是什么"><a href="#linux-redhat-debian-centos-redhat是什么" class="headerlink" title="linux redhat debian centos redhat是什么"></a>linux redhat debian centos redhat是什么</h3><h4 id="linux通常是指运行linux内核的操作系统"><a href="#linux通常是指运行linux内核的操作系统" class="headerlink" title="linux通常是指运行linux内核的操作系统"></a>linux通常是指运行linux内核的操作系统</h4><blockquote><p>linux主要发行版分为两类，一类是由商业维护比如redhat,一类是由社区维护比如debian。<br>两个系列的操作系统主要区别于包管理命令(redhat系列使用yum,debian系列使用apt-get),其他命令因为都是linux内核则大同小异。</p></blockquote><h4 id="Debian系列"><a href="#Debian系列" class="headerlink" title="Debian系列"></a>Debian系列</h4><blockquote><p>Debian是一个基于Linux内核为主的操作系统，Debian是社区类Linux发展的典范，是迄今为止最遵循GNU规范的Linux系统，该系列主要包含：debian和Ubuntu。<br>Debian最具特色的是apt-get&#x2F;dpkg包管理方式。<br>其实redhat的YUM也是在模仿debian的apt方式，但在二进制文件发行方式中，apt应该是最好的了。<br>Debian倾向于稳定，经过长时间验证的更新才会被应用于系统内，而Ubuntu倾向于把新东西整进来，所以在服务器方面，Debian是比Ubuntu更适合，也更轻（服务器不需要界面）。</p></blockquote><ul><li>Ubuntu<blockquote><p>Ubuntu拥有debian所有的优点，以及自己所加强的优点的近乎完美的Linux桌面系统。<br>Ubuntu也是Debian的衍生版本（友好的界面，简单的操作，可以帮助人们尽快熟悉Linux）。</p></blockquote></li><li>Tails<blockquote><p>Tails是Debian的衍生版本（Tails的目的就是为了帮助用户实现匿名上网，并最大限度保护个人隐私）。</p></blockquote></li></ul><h4 id="redhat系列"><a href="#redhat系列" class="headerlink" title="redhat系列"></a>redhat系列</h4><blockquote><p>redhat系列大概有以下几个：RHEL(redhat enterprise linux)、Fedora core、centos。</p></blockquote><ul><li>RHEL<blockquote><p>redhat公司发行的收费版，非常稳定。</p></blockquote></li><li>centos<blockquote><p>redhat的社区版，功能和RHEL类似，但免费。</p></blockquote></li><li>Fedora<blockquote><p>redhat的桌面版本，界面优雅，功能和工具版本都非常靠前，但不是很稳定。</p></blockquote></li></ul><h4 id><a href="#" class="headerlink" title></a></h4><h3 id="gcc-glibc-libstdc-g-之间的关系"><a href="#gcc-glibc-libstdc-g-之间的关系" class="headerlink" title="gcc glibc libstdc++ g++之间的关系"></a>gcc glibc libstdc++ g++之间的关系</h3><h4 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h4><blockquote><p>gcc是编译器,源码中带有c标准库的实现glibc和c++标准库实现libstdc++<br>gcc默认编译c代码,如果需要编译.cpp代码需要加上编译选项<code>gcc -lstdc++</code><br><a href="https://ftp.gnu.org/gnu/gcc/">下载地址</a></p></blockquote><h4 id="glibc"><a href="#glibc" class="headerlink" title="glibc"></a>glibc</h4><blockquote><p>通常编译成动态库 libc.so.*<br>实现了基础函数库：字符串库、日期时间、IO、并发支持、常见算法等<br>C标准库是系统中的底层API,封装系统调用函数,可以和操作系统、硬件交互<br><a href="https://zh.cppreference.com/w/c">C标准库文档</a><br>linux内核也是c写的,但是不依赖c标准库,内核实现的是系统级函数,所以glibc标准库会调用内核里的系统函数</p></blockquote><h4 id="libstdc"><a href="#libstdc" class="headerlink" title="libstdc++"></a>libstdc++</h4><blockquote><p>它是gcc实现的c++标准库,对应clang编译器的c++标准库是libc++<br>通常编译成动态库 libstdc++.so.*.*.*<br>通常我们编译c++程序是动态链接,但有时候为了更好的让代码在不同的机器上运行，我们希望静态链接libstdc++.a,这样更方便移植。所以gcc编译时可以添加链接选项<code>gcc -static-libstdc++</code><br>查看可执行程序使用的是静态还是动态库,可以使用ldd命令查看程序依赖哪些动态库,如下: 程序a依赖libstdc++动态库</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@doc tmp]# ldd a<br>linux-vdso.so.1 =&gt;  (0x00007ffee3d02000)<br>libstdc++.so.6 =&gt; /lib64/libstdc++.so.6 (0x00007f0f381c1000)<br>libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f0f37df3000)<br>libm.so.6 =&gt; /lib64/libm.so.6 (0x00007f0f37af1000)<br>/lib64/ld-linux-x86-64.so.2 (0x00007f0f384c9000)<br>libgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x00007f0f378db000)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>gcc</tag>
      
      <tag>libstdc++</tag>
      
      <tag>glic</tag>
      
      <tag>编译</tag>
      
      <tag>链接</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/02/16/hello-world/"/>
    <url>/2023/02/16/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
