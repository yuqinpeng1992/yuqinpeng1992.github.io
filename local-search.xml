<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>leetcode之字符串</title>
    <link href="/2023/02/23/leetcode%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2023/02/23/leetcode%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h4 id="字符串理论基础"><a href="#字符串理论基础" class="headerlink" title="字符串理论基础"></a>字符串理论基础</h4><blockquote><p>存储字符类型的变长数组</p></blockquote><h4 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串</a></h4><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。<br>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。<br>示例 1：<br>输入：s &#x3D; [“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]<br>示例 2：<br>输入：s &#x3D; [“H”,”a”,”n”,”n”,”a”,”h”]<br>输出：[“h”,”a”,”n”,”n”,”a”,”H”]</p><h5 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h5><p>我们定义两个指针（也可以说是索引下标），一个从字符串前面，一个从字符串后面，两个指针同时向中间移动，并交换元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//双指针 一个指向头 一个指向尾 ,每次交换后头尾指针往中间走</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; s)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; left &lt; right; ++left, --right) &#123;<br>std::<span class="hljs-built_in">swap</span>(s[left], s[right]);<br>&#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="541-反转字符串-II"><a href="#541-反转字符串-II" class="headerlink" title="541. 反转字符串 II"></a><a href="https://leetcode.cn/problems/reverse-string-ii/">541. 反转字符串 II</a></h4><p>给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。<br>如果剩余字符少于 k 个，则将剩余字符全部反转。<br>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。<br>示例 1：<br>输入：s &#x3D; “abcdefg”, k &#x3D; 2<br>输出：”bacdfeg”<br>示例 2：<br>输入：s &#x3D; “abcd”, k &#x3D; 2<br>输出：”bacd”</p><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>把整个字符串按照2k的长度分组,每组翻转前一半字符串<br>最后一组可能不够k个字符, 则剩余的全部字符全部翻转</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseStr</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> index = <span class="hljs-number">0</span>; index &lt; n; index += (<span class="hljs-number">2</span> * k)) &#123;<br>            <span class="hljs-keyword">if</span> (index + k &lt; n) &#123;<br>                std::<span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + index, s.<span class="hljs-built_in">begin</span>() + index + k);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                std::<span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + index, s.<span class="hljs-built_in">end</span>());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h4><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。<br>示例 1：<br>输入：s &#x3D; “We are happy.”<br>输出：”We%20are%20happy.”</p><h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>扩容数组到空格替换成”%20”后的大小<br>从后往前遍历,把空格替换成”%20”,从后往前的原因是当替换索引index的空格时, 不会覆盖空格之前的字符串,时间复杂度为o(n)<br>如果从前往后遍历,当替换索引index的空格时,为了保持替换是不会覆盖原本的字符串,需要把index之后的数据全都往后移动3个位置,时间复杂度为o(n^2)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">replaceSpace</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> oldSize = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> newSize = oldSize;<br><span class="hljs-comment">//扩容s的大小</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; c : s) &#123;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                newSize += <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        s.<span class="hljs-built_in">resize</span>(newSize);<br><span class="hljs-comment">//从后往前替换</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = newSize - <span class="hljs-number">1</span>, j = oldSize - <span class="hljs-number">1</span>; j &lt; i; j--, i--) &#123;<br>            <span class="hljs-keyword">if</span> (s[j] != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                s[i] = s[j];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                s[i] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                s[i - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>                s[i - <span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;%&#x27;</span>;<br>                i -= <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>双指针</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode之数组</title>
    <link href="/2023/02/22/leetcode%E4%B9%8B%E6%95%B0%E7%BB%84/"/>
    <url>/2023/02/22/leetcode%E4%B9%8B%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h4 id="数组基础理论"><a href="#数组基础理论" class="headerlink" title="数组基础理论"></a>数组基础理论</h4><p><a href="https://zh.wikipedia.org/zh-my/%E6%95%B0%E7%BB%84">维基百科</a></p><blockquote><p>数组是存储相同类型的元素的集合，分配一块连续的内存来存储。利用元素的索引（index）可以根据地址偏移计算出该元素对应的存储地址。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[<span class="hljs-number">3</span>] = &#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span> &#125;;<br><span class="hljs-comment">//b和c 其实是一样的</span><br><span class="hljs-type">int</span> a = arr[<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> b = *((<span class="hljs-type">int</span>*)(arr + <span class="hljs-number">2</span>));<br><br></code></pre></td></tr></table></figure><h4 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></h4><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。<br>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。<br>示例 1: 给定 nums &#x3D; [3,2,2,3], val &#x3D; 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。<br>示例 2: 给定 nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//双指针</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>    <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>;<br>      <span class="hljs-type">int</span> len = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-comment">//fast遍历整个数组,不等于val的N个数存到数组的前N个位置,N由slow=0开始自增</span><br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> fast=<span class="hljs-number">0</span>; fast &lt; len; fast++)<br>      &#123;<br>        <span class="hljs-keyword">if</span>(nums[fast] != val) &#123;<br>            nums[slow++] = nums[fast];<br>          &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> slow;<br>  &#125;<br>    <span class="hljs-comment">//双指针优化 题目要求可以改变数组元素的顺序</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElemet2</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> val)</span> </span>&#123;<br><span class="hljs-comment">//左指针left索引的元素不等于val,说明不用删除,则后移</span><br><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> len = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-comment">//左指针left索引的元素等于val 则替换成右指针right-1索引的数值, 右指针right-1这个数被替换到slow了,右指针right-1这个数没用了,右指针right前移</span><br>  <span class="hljs-type">int</span> right = len;<br>  <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>  <span class="hljs-keyword">if</span> (nums[left] == val) &#123;<br>  nums[left] = nums[right - <span class="hljs-number">1</span>];<br>  --right;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>  ++left;<br>&#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> left;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977. 有序数组的平方"></a><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></h4><p>给你一个按非递减顺序排序的整数数组nums返回每个数字的平方组成的新数组要求也按非递减顺序排序。<br>示例 1：<br>输入：nums &#x3D; [-4,-1,0,3,10]<br>输出：[0,1,9,16,100]<br>解释：平方后，数组变为 [16,1,0,9,100]<br>排序后，数组变为 [0,1,9,16,100]<br>示例 2：<br>输入：nums &#x3D; [-7,-3,2,3,11]<br>输出：[4,9,9,49,121]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortedSquares</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-comment">//由于任意数的平方必定是正数,nums是有序的,所以平方后最大值要么是nums[0]*nums[0]要么是nums[n-1] * nums[n - 1]</span><br>    <span class="hljs-comment">//此时可以使用双指针 i = 0 j = nums.size() - 1</span><br><span class="hljs-comment">//使用索引k指向结果数组的最后一个元素</span><br><span class="hljs-comment">//如果 nums[i] * nums[i] &gt;= nums[j] * nums[j]  则result[k] = nums[i] * nums[i] k--</span><br><span class="hljs-comment">//如果 nums[i] * nums[i] &lt; nums[j] * nums[j]  则result[k] = nums[j] * nums[j]  k--</span><br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> k = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = n - <span class="hljs-number">1</span>; i &lt;= j;) &#123;<br>            <span class="hljs-keyword">if</span> ((nums[i] * nums[i]) &gt;= (nums[j] * nums[j])) &#123;<br>                result[k--] = nums[i] * nums[i];<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                result[k--] = nums[j] * nums[j];<br>                j--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></h4><p>给定一个含有 n 个正整数的数组和一个正整数 target 。<br>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。<br>示例 1：<br>输入：target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]<br>输出：2<br>解释：子数组 [4,3] 是该条件下的长度最小的子数组。<br>示例 2：<br>输入：target &#x3D; 4, nums &#x3D; [1,4,4]<br>输出：1<br>示例 3：<br>输入：target &#x3D; 11, nums &#x3D; [1,1,1,1,1,1,1,1]<br>输出：0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//暴力求解</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-type">int</span> len = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-type">int</span> min = len + <span class="hljs-number">1</span>;<span class="hljs-comment">//代表最小子数组长度,如果存在正确答案肯定小于n+1</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j &lt; len; ++j)<br>&#123;<br>sum += nums[j];<br><span class="hljs-keyword">if</span>(sum &gt;= target)<br>&#123;<br>min = std::<span class="hljs-built_in">min</span>(min, j - i + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> min == len + <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : min;<br>&#125;<br><span class="hljs-comment">//滑动窗口</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-type">int</span> min = n + <span class="hljs-number">1</span>;<span class="hljs-comment">//代表最小子数组长度,如果存在正确答案肯定小于n+1</span><br><span class="hljs-comment">//由于必须是连续的子数组总和&gt;=target,所以使用双指针</span><br><span class="hljs-comment">//左指针初始=0</span><br><span class="hljs-comment">//右指针right初始=0,累加到sum, right后移自增, 当sum&gt;=target 计算右指针和左指针的距离distance=right - left , min=std::min(min, distance) </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> left=<span class="hljs-number">0</span>, right=<span class="hljs-number">0</span>; right &lt; n;)<br>&#123;<br>sum += nums[right];<br>++right;<br><span class="hljs-comment">//因为加上这个数可能很大 所以要不断地减去当前left索引对应的数,并且left往后移动,直到sum &lt; target</span><br><span class="hljs-keyword">while</span>(sum &gt;= target)<br>&#123;<br>min = std::<span class="hljs-built_in">min</span>(min,  right - left);<br>sum -= nums[left++];<br>&#125;<br><span class="hljs-comment">//不会有比1更短的数组了</span><br><span class="hljs-keyword">if</span>(min == <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> min == n + <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : min;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59. 螺旋矩阵 II"></a><a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></h4><p>给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。<br>示例 1：<br>输入：n &#x3D; 3<br>输出：[[1,2,3],[8,9,4],[7,6,5]]</p><p><img src="1.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//顺时针循环的方向,按照行列的切换有4个方向 行不变,列+1 | 行+1,列不变 | 行不变,列-1 | 行-1,列不变</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> DIRS[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">generateMatrix</span>(<span class="hljs-type">int</span> n) &#123;<br><span class="hljs-type">int</span> total = n * n;<br><span class="hljs-type">int</span> row = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> col = <span class="hljs-number">0</span>;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">result</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br><span class="hljs-type">int</span> dirIndex = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; total; ++i)<br>&#123;<br>result[row][col] = i + <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> nextRow = row + DIRS[dirIndex][<span class="hljs-number">0</span>];<br><span class="hljs-type">int</span> nextCol = col + DIRS[dirIndex][<span class="hljs-number">1</span>];<br><span class="hljs-comment">//边界和已访问处理</span><br><span class="hljs-keyword">if</span>(nextRow &lt; <span class="hljs-number">0</span> || nextRow &gt;= n || nextCol &lt; <span class="hljs-number">0</span> || nextCol &gt;= n || result[nextRow][nextCol] != <span class="hljs-number">0</span>) &#123;<br>dirIndex = (dirIndex + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;<br>&#125;<br>row = row + DIRS[dirIndex][<span class="hljs-number">0</span>];<br>col = col + DIRS[dirIndex][<span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></h4><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。<br>示例 1:<br>输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 9<br>输出: 4<br>解释: 9 出现在 nums 中并且下标为 4<br>示例 2:<br>输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 2<br>输出: -1<br>解释: 2 不存在 nums 中因此返回 -1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//[]闭闭区间控制</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br><span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> finish = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (start &lt;= finish) &#123;<br><span class="hljs-comment">//不能用(start + finish) / 2,start+finish可能溢出</span><br><span class="hljs-type">int</span> mid = start + (finish - start) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br><span class="hljs-keyword">return</span> mid;<br>&#125;<br><span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>finish = mid - <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>start = mid + <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><span class="hljs-comment">//[)闭开区间控制</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search2</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br><span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> finish = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">while</span> (start &lt; finish) &#123;<br><span class="hljs-comment">//不能用(start + finish) / 2,start+finish可能溢出</span><br><span class="hljs-type">int</span> mid = start + (finish - start) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br><span class="hljs-keyword">return</span> mid;<br>&#125;<br><span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>finish = mid;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>start = mid + <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>数组</tag>
      
      <tag>双指针</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>现代处理器架构</title>
    <link href="/2023/02/17/%E7%8E%B0%E4%BB%A3%E5%A4%84%E7%90%86%E5%99%A8%E6%9E%B6%E6%9E%84/"/>
    <url>/2023/02/17/%E7%8E%B0%E4%BB%A3%E5%A4%84%E7%90%86%E5%99%A8%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="现代处理器架构"><a href="#现代处理器架构" class="headerlink" title="现代处理器架构"></a>现代处理器架构</h2><blockquote><p>主要说说这几个方面:<br>流水线<br>多核和超线程<br>SIMD指令集<br>缓存和缓存机制</p></blockquote><h3 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h3><blockquote><p>传统的认识就是cpu的主频越高,性能越高。其实这里面有一个前提：同样的流水线架构<br>实现指令级并行</p></blockquote><h4 id="多发射-超标量处理器"><a href="#多发射-超标量处理器" class="headerlink" title="多发射-超标量处理器"></a>多发射-超标量处理器</h4><h4 id="数据依赖和延迟"><a href="#数据依赖和延迟" class="headerlink" title="数据依赖和延迟"></a>数据依赖和延迟</h4><h4 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h4><blockquote><p>减少延迟 最大化流水线和多发射的效率</p></blockquote><ul><li>条件转移指令</li></ul><h4 id="乱序执行"><a href="#乱序执行" class="headerlink" title="乱序执行"></a>乱序执行</h4><blockquote><p>编译器静态调整<br>CPU动态调整<br>让没有数据依赖的指令提前执行 提升cpu效率</p></blockquote><h4 id="多核和超线程"><a href="#多核和超线程" class="headerlink" title="多核和超线程"></a>多核和超线程</h4><h4 id="SIMD指令集-单指令多数据-single-instruction-multiple-data"><a href="#SIMD指令集-单指令多数据-single-instruction-multiple-data" class="headerlink" title="SIMD指令集 (单指令多数据 single instruction multiple data)"></a>SIMD指令集 (单指令多数据 single instruction multiple data)</h4><h4 id="CPU-CACHE"><a href="#CPU-CACHE" class="headerlink" title="CPU CACHE"></a>CPU CACHE</h4><blockquote><p>现代cpu太快了，访问内存变成了一个拖油瓶相当耗时的事情，所以增加了CPU 缓存<br>cpu缓存容量有限会进行LRU动态更新，对于程序员来说应该尽量保证代码的空间和时间局部性<br>时间局部性指的是同块内存重复使用<br>空间局部性指的是代码执行更多的访问相邻的内存</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2023/02/17</title>
    <link href="/2023/02/17/2023-02-17/"/>
    <url>/2023/02/17/2023-02-17/</url>
    
    <content type="html"><![CDATA[<h3 id="GNU与Linux"><a href="#GNU与Linux" class="headerlink" title="GNU与Linux"></a>GNU与Linux</h3><blockquote><p>一个叫Richard Matthew Stallman的大胡子美国大叔对UNIX系统封闭源码很不满意，于1984年发起了GNU计划(GNU is Not Unix，首字母递归缩写)，计划开发一个完全兼容UNIX的自由软件系统，为此专门成立了自由软件基金会(Free Software Foundation，FSF)。FSF是打算自己开发一个开源的类UNIX系统,但是进度缓慢。</p><p>后面天才小子Linus Torvalds开发出了Linux,Linus觉得GNU开源精神不错,自己也不想折腾配套的应用软件(gcc、编辑器)等,双方就进行了整合组成了完整的操作系统发行版。FSF表示没什么意见，只是坚持要求全称应该叫“GNU&#x2F;Linux”，光叫Linux 就把GNU的成果完全忽略掉了。</p><p>GNU&#x2F;Linux的诞生和发展，是一件足以影响计算机行业发展史的大事。不过好像大家都习惯简称Linux,RMS大叔至今谈到GNU没有开发出自己的操作系统就泪流满面。</p></blockquote><h3 id="linux-redhat-debian-centos-redhat是什么"><a href="#linux-redhat-debian-centos-redhat是什么" class="headerlink" title="linux redhat debian centos redhat是什么"></a>linux redhat debian centos redhat是什么</h3><h4 id="linux通常是指运行linux内核的操作系统"><a href="#linux通常是指运行linux内核的操作系统" class="headerlink" title="linux通常是指运行linux内核的操作系统"></a>linux通常是指运行linux内核的操作系统</h4><blockquote><p>linux主要发行版分为两类，一类是由商业维护比如redhat,一类是由社区维护比如debian。<br>两个系列的操作系统主要区别于包管理命令(redhat系列使用yum,debian系列使用apt-get),其他命令因为都是linux内核则大同小异。</p></blockquote><h4 id="Debian系列"><a href="#Debian系列" class="headerlink" title="Debian系列"></a>Debian系列</h4><blockquote><p>Debian是一个基于Linux内核为主的操作系统，Debian是社区类Linux发展的典范，是迄今为止最遵循GNU规范的Linux系统，该系列主要包含：debian和Ubuntu。<br>Debian最具特色的是apt-get&#x2F;dpkg包管理方式。<br>其实redhat的YUM也是在模仿debian的apt方式，但在二进制文件发行方式中，apt应该是最好的了。<br>Debian倾向于稳定，经过长时间验证的更新才会被应用于系统内，而Ubuntu倾向于把新东西整进来，所以在服务器方面，Debian是比Ubuntu更适合，也更轻（服务器不需要界面）。</p></blockquote><ul><li>Ubuntu<blockquote><p>Ubuntu拥有debian所有的优点，以及自己所加强的优点的近乎完美的Linux桌面系统。<br>Ubuntu也是Debian的衍生版本（友好的界面，简单的操作，可以帮助人们尽快熟悉Linux）。</p></blockquote></li><li>Tails<blockquote><p>Tails是Debian的衍生版本（Tails的目的就是为了帮助用户实现匿名上网，并最大限度保护个人隐私）。</p></blockquote></li></ul><h4 id="redhat系列"><a href="#redhat系列" class="headerlink" title="redhat系列"></a>redhat系列</h4><blockquote><p>redhat系列大概有以下几个：RHEL(redhat enterprise linux)、Fedora core、centos。</p></blockquote><ul><li>RHEL<blockquote><p>redhat公司发行的收费版，非常稳定。</p></blockquote></li><li>centos<blockquote><p>redhat的社区版，功能和RHEL类似，但免费。</p></blockquote></li><li>Fedora<blockquote><p>redhat的桌面版本，界面优雅，功能和工具版本都非常靠前，但不是很稳定。</p></blockquote></li></ul><h4 id><a href="#" class="headerlink" title></a></h4><h3 id="gcc-glibc-libstdc-g-之间的关系"><a href="#gcc-glibc-libstdc-g-之间的关系" class="headerlink" title="gcc glibc libstdc++ g++之间的关系"></a>gcc glibc libstdc++ g++之间的关系</h3><h4 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h4><blockquote><p>gcc是编译器,源码中带有c标准库的实现glibc和c++标准库实现libstdc++<br>gcc默认编译c代码,如果需要编译.cpp代码需要加上编译选项<code>gcc -lstdc++</code><br><a href="https://ftp.gnu.org/gnu/gcc/">下载地址</a></p></blockquote><h4 id="glibc"><a href="#glibc" class="headerlink" title="glibc"></a>glibc</h4><blockquote><p>通常编译成动态库 libc.so.*<br>实现了基础函数库：字符串库、日期时间、IO、并发支持、常见算法等<br>C标准库是系统中的底层API,封装系统调用函数,可以和操作系统、硬件交互<br><a href="https://zh.cppreference.com/w/c">C标准库文档</a><br>linux内核也是c写的,但是不依赖c标准库,内核实现的是系统级函数,所以glibc标准库会调用内核里的系统函数</p></blockquote><h4 id="libstdc"><a href="#libstdc" class="headerlink" title="libstdc++"></a>libstdc++</h4><blockquote><p>它是gcc实现的c++标准库,对应clang编译器的c++标准库是libc++<br>通常编译成动态库 libstdc++.so.*.*.*<br>通常我们编译c++程序是动态链接,但有时候为了更好的让代码在不同的机器上运行，我们希望静态链接libstdc++.a,这样更方便移植。所以gcc编译时可以添加链接选项<code>gcc -static-libstdc++</code><br>查看可执行程序使用的是静态还是动态库,可以使用ldd命令查看程序依赖哪些动态库,如下: 程序a依赖libstdc++动态库</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@doc tmp]# ldd a<br>linux-vdso.so.1 =&gt;  (0x00007ffee3d02000)<br>libstdc++.so.6 =&gt; /lib64/libstdc++.so.6 (0x00007f0f381c1000)<br>libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f0f37df3000)<br>libm.so.6 =&gt; /lib64/libm.so.6 (0x00007f0f37af1000)<br>/lib64/ld-linux-x86-64.so.2 (0x00007f0f384c9000)<br>libgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x00007f0f378db000)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>gcc</tag>
      
      <tag>libstdc++</tag>
      
      <tag>glic</tag>
      
      <tag>编译</tag>
      
      <tag>链接</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/02/16/hello-world/"/>
    <url>/2023/02/16/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
